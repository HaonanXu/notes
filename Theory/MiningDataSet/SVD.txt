SVD
A[m * n] = U [m * r] Sig[r*r](V[n*r])^T
r: rank of the matrix A. 

U: left singular vectors, r concepts, user to concept
Sig, singular values: concept strength

V:right singluar vectors: movie-to-concept

Always possible to decompose A where U, Sig, V, unique, U, V, coulmn orthonormal, Sig: diagonal
----------
SVD: best axis to project on: min sum of squares of projection erros =? minimum reconstruction error

use movie-to-concept to find axis => Sig gives spread on the axis

U*Sig = coordinates of proints in the axis

How to do dr: set smallest singular values to zero

how to mark similarily of matrices

-----

SVD: best low rank approx.

U = sig1 * U1 * V1^T + sig2 * U2 ....
Ui and Vi are unti length, sigi scales them

How many sigs to keep => preserve Ssig(i)^2

--------
map query into a concep space?
q(concept) = q * V

relation to eigen-decomposition:

singular vectors are dense

-------
make A = C* U * R make ||A - C* U * R||f small

Constraint: C contains cols from A, R contains rows from A, U psedudo-inverse of the interseciton of C and R

Ak , is SVD of A of rank k, CUR in O(mn) s.t. reconstruct error of CUR 
<= |A-Ak|f + Ep |A|f, with probablility at least 1 - ep, by picking
in practice pick 4k cons/rows
------
for A: m *n, sample size c

col case for c
for x = 1: n
	calc P(x)
for i = 1 : c
	pick j in [1..n] based on P(x)
	compute Cd(:, i)

let W the intersecion of sampled cols C and R, W = XZY^T
then U = YZ+X^T, Z+: 1/Zii
-----
CUR: basis vectors are actual cols and rows, and basis will be sparse, but may have duplicate ocls and rows
to handle duplicate: throw away, or scale the cols/rows by the square root of # of nums

In SVD, Sig is sparse and small, U is dense and small