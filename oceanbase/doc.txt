Root Server:
colocated with US, each cluster has only ONE US
when swtich primary and backup, new RS uses internal table to recover source of truth reqeusted by the cluster

Chuck Server:
colocated with MS. Read US within the same cluster, if not available, then read backup US from other cluster, and finally read the active US

LMS: 
colocated with RS, query cluster's internal table on primary and backup's traffic info, and address's of other MS

----------------
RS uses RootTable, which stores all tablet's size, checksum, and location

User Meta Table, each UT has one, each row mapps to a Tablet in UT, stores location of UserTablet, UMT itself may be in multiple tablets

User Root Table, only 1 tablet, every row corresponds to a Tablet in UMT, stores its location

First Root Table: every row corresponds to a user root table, stores URT's location info. Only 1 tablet, and can not be splited

FRT stays in memory.all URT in cluster are cached. 
since UMT and UT are splittable, caches are evicted
-------

RS updates RT with Tablets reported by CS, if tablet's range split point is not consistent, need to rollback change to RootTable

For each Tablet A reported, query the RT to get rows that intersects with A's range

1. if nothing returns, we have a new row
2. if range exactly one row that is  same, just update that row
3. if range A is the union of some rows, this means we merge
4. if range A is the subset of a single row, this means we split it into 2 or 3 rows

--------
RS has a special process just to rebalance Tablet replication and relocation, and add coreesponding rep/relocation task to relocation server's task list.
RS has another special process to scan all chuck server, and execute migration tasks on each CS

-------

When create a table
1. assign new table ids to URT, UMT , and UT, respectivly 
2. create UMT: create schema based on the definition of UT, choose CS and create Tablet 
3. create URT: create schema based on UMT, choose CS and create Tablet
4. choose ChuckServer, and create UT tablet
5. record the schema of 3 tables into Schema related tables
6. renew schema manager, and sync to other servers
7. Update URT, UMT, UT, location in each's parent

when delete table. Note deletion of tablet is async
1. delete UT, UMT, and URT, info in 3 core tables
2. renew schema manager, and sync to other servers

-------
BootStrap
1. creat FRT, and record its tablet location
2. create core schema tables __all_table, __all_all_column, __all_join_info, __all_dll_operation, in each case, choose CS and create tablet, and then add record to FRT
3. create other system tables: 
choose ChunkServer and create empty Tablet
add that new record to FRT
update Schema related system tables, and record it in schema
4. Read system table, update schema manager, and sync it to CS, MS , and main US
5. Init certain system table's data

Note interal tablet goes directly to FRT

-------

-------
client r/w requests go to active US, daily merge or version read goes to backup US

active and backup US use Paxos to sync CommitLog. Sync request is async, but write to disk is sync

Sequence of actions
1. main US sends CL to backup US
2. backup US stores commitLog to a circular buffer
3. backup US acks an nsync, marks as in progress
4. backup US chance its status to sync, and synchronously write log in buffer onto journal on disk
5. backup acks written transaction  to main US

if main US's sync req times out all the time, it sends itself as backup, and RS will pick a new update server

-------
RS will pick the US with highest log ts as main US
US uses lease to keep communication with RS
main US syncs commit log to backup US

head of each commit file has the commited ID of the machine when this file is generated to identify log generation time when replay the log, and which is commited.
When a backup US replays the log, it can only replay to the last file's commited id, anything beyond that must be retriveved from the new active US, remaining log files needs to be renamed and logically deleted 

------
MS generates logical query plan and physical query plan. MS itself is stateless. 
SuperBlock/SuperBlockBackup/Block1/Block2/Block3 .../BlockN

Inside each SSTable block

1. MacroBlockCommon Header
2. SSTable MacroBlockHeader
3. N microblocks
4. Mincroblock index
5. MicroBlock EndKey

-------

When migrating into a new tablet
1. read 1 macro block from source
2. select a local disk and find corresponding data file
3. give a tablet metadata, and assign a new macroblock in the data file
4. write macroblock, modify macroblock metadata, add this macroblock to tablet's list of macroblock metadata
5. Add tablet metadata into TabletImage, and record commit log

--------

1. allocate two macro blocks of memory
2. pick a tablet from tablet image, and read through all its MacroBlocks
3. merge data with UpdateServer, write to the memories
4. if both memories are full, flush first one to data file, which means...
	a. new macroblock
	b. update macroblock metadata
	c. append new tablet metadata
	d. clear first block
	e. swap two memory block sequence, keep writing
5. repeaat 3-4 until there is no macroblock to update
6. calculate split point in new macroblock metadata, split tablet metadata into multiple macroblock metadata list
7. add new tablet metadata into new version of tabletimage

------

reset macro blocks?



