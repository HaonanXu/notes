In FP, we break programs down into functions that perform some ops
In OOP, we break programs down into classes that give behavior to some kind of data => need double dispatch to deal with ops with multiple arguments

Example:
Expression for language such as for arithmetic
variatns of expressions: int, neg, add
operations over expressions: eval them, convert to strings, hasZero

FP approach
datatype for expressions, with one ctor for each variant
define function for each operation
in each function, have a branch for each variant of data => may use wildcard pattern to avoid enumberation all the branches

i.e., procedural decomposition => each procedure corresponds to each operation

OOP
define a class for expressions
subclass for each variant of data
in each subclass, have a mehtod def for each ops => use super class to implement default behaviour

If we add a new op
FP approach: 
add a new function
add a new data type
all functions with a new case

Exactly opposite with FP approach

-------
visitor pattern in OOP to support new operations (often with double dispatch)
IN FP, can find datatypes to have an "other" posibility and opertions to take in a function that can process the "other data"

Note you can not wrap the original datatype in a newdatatype to support new data type => so your ADD can not have Mult

In fact, languages often provide contructs exactly to prevent extensibility: ML moduels can hide datatpes, Java's final prevents subclasses

---
example: suppose now we have rational number and strings as expression
if the arguments are ints or rationals, do the arithmetic
if either agument is a string, convert the other arugment to a string and return the concat of the strings

=> add_values will be really complex
---
OOP

helper function is not oop, each value should know how to add
=> e1.eval.add_values e2.eval
but in the add_values implementation, we will have to do is_a? check, which counters OOP style

Root problem: we need to know the type => so replace is_a? with the type's call

so 

def add_values v
v.addInt self
end

def addInt v
	Int.new(v.i + i)
end

----
mixin:
mixin methods calling methods that they assume are defined in all clasess that inluce the mixin, somewhere between multiple inheritance and interface

interface:
fundamental to type checking, which is why they dont exist in ruby

module Color
	attr_acceotr:color
	def darken
		self.color = "dart" + self.color
	end
end

class ColorPt < Pt
	include Color
end

often, mixins call other methods on self that are not defined by the mixin. Instead, the mixin assumes that all clases that include the mixin define this method

interface: purely for type checking purposes. Therefore, no need for dynamically-typed languages to have interface. Similarly there is no need to have abstract method 

---
Type system flexibility
ML: parametric polymorphism/generics
C#: subtype polymorphism/subtyping

---

idea subtyuping

if some exp has a record type, then let hte expresison also have a type where some of the fields are removed => letting an expression that has one type also hae another type that has less information is the idea of subtyping

if our goal is to prevent field-missing erors, then we cannot add any subtyping rules that would cause su to stop metting our goal => "subtyping is not a matter of opinion"

so "depth checking"

e.g. passing a sphere into a circle function => will not type check, because the type is {{x, y, z}, r} instead of {{x, y}, r}

if ta <: tb then {f1:t1,....,f:ta,...fn:tn} <: {f1:t1,....,f:tb,...,fn:tn}

problem: the member will be mutated into a supertype!!=> so if the field is not settable (immutable) depth subtyping rule is sound

------

Java's array allows depth subcheckng, and will raise runtime excpetion if the subtype array is assigned a supertype

Java and c# allow null to have any object type, so every feild access and method call includes a run-time check for null => NullPonterException => proposals to never hold null support, e.g., Option types in ML

---
function subtyping
if ta <: tb then t->ta <: t-> tb => return tyeps are covariants for function subtyping meaning the suttyping fo rthe return types works "the same way" as for types overall

but arugment types are NOT covariant for function subtyping => but contravariance, i.e. => f accepting super type

needed for higher-order functions or for stoirng functions themselves in records

---
a subtype can have extra fields
because fiels ar emutable, a subtype cannot have a different type for a feild
a sybytpe can have extra methods
because methods are immutable, a subytpe can have a subtype for a mehtod, which means the method in the subtype can have contravariant argument types ans a covaraint result type
=> a subclass can override a method a with a covaraint return type

class and types are different! => class defines an object's behavior, a type describes what fiels an object has and what messages it can reponsd to

in general, when you use Object and downcasts, you are essentially taking a dynamic typing approach

key of generic => mark mutliple uses of that is of same type
---
bounded generic types:
instead of just saying "a subtype of T" or "for all types 'a" => for all types 'a that are a subtype of T =>

static <T extneds Pt> List<T> inCircle(List<T> pts, Pt center, double radius)
{
}
