lists, immutable, recursive, array is flat

val empty: List[Nothing] = List();

fruit = Nil

nums = "apples" :: ("oragnes" :: (....

con is right associteated

all ops can be expressed as head, tail and isEmpty

List(p :: ps) a pattern that matches head as P, and tail as ps

pattern x::y :: List(xs, ys) :: zs

def isort(xs: List[Int]):ListpInt] = xs match
{
	case List() => List()
	case y ::ys => insert(y, isort(ys))
}

ex. implement insertion

def last{T](xs: List[T}):T = xs match
{
	casae List() => throw new Error("warning")
	case List(x) => x
	case y :: ys => last(ys)
}

def concat[T](xs: List[T], ys: List[T]) = xs mathc {
	case List() => ys
	cae z:: zs => z :: concat(zs, ys)
}

revserse(us) ++ List(y)

(xs take n) :::(xs drop n+1)

 ..= (xs, ys) match
{
	case (x:: xs1, y ::ys1) =>
		if (x< y) x:: merge (xs1, ys)
}

val nums = List(2, -4, 5, 7,1)
pair (x,y)

pattern matching val(lable, value) = pair

make merge sort more general?  supply a comparison function

def (msort[T](xs: List[T])(lt: (T, T) => Boolean)
merge(msort(fst)(lt), msort(snd)(lt))

use Ordering to save the lambda

implicit parameters compiler will figure out type for you

implementationt of reduceLeft and FoldLeft

foldReight and reduceRight
