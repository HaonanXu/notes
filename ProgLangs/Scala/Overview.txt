1. collection
list is defined recursively. It has two parts: 
head: top element
tail: the remaining elements as list

therefore, constructing a list would be

x :: (y :: (z :: {another list})) 

:: is the concatinate operator

2. pattern matching

insight: when we get an object type, we may care more about its content than its type

Therefore, you can map an object to its constructor so that you can access the object's content

e.g.

def insertionSort(xs: List[int]) : List[Int] =
	xs match{
	case List() => List()
	case y :: ys => insert(y, insertionSort(ys))
}

If xs is empty, it will match the List() ctor. 
Otherwise, it will match y :: ys ctor, and you have full knowledge of list's contect y and ys

a follow up example

def insert(x:Int, xs: List[Int]): List[Inx] =
	xs match{
	case List() => List(x)
	case y:: ys =>
		if (x <= y)
			x :: xs
		else
			y :: insert(x, ys)
}


3.pair /tuple...etc

val pair = ("answer", 42)
val (label, value) = pair

lable will be "answer", value will be 42

example the merge routine in merge sort

def merge(xs: List[Int], ys: List[Int]) : List[Int] =
	(xs, ys) match{
		case(xs, nil): xs
		case(nil, ys): ys
		case(x::xss, y::yss):
			if (x < y)
				x :: merge(xss, ys)
			else
				y:: merge(xs, yss) 
	}


5. the fold operator

goal, reduce all elements in the collection into an accumulator

e,g. sum(xs: List[Int]) =
	(xs foldLeft 0) ((x, y) => x +y)

here 0 is the accumulator, we collapse all elements in xs into 0

another example

def concat(xs: List[Int], ys: List[Int]) : List [Int] =
	(xs foldRight ys) ((x, y) => x:: y)

6. function as object

function is just object with apply methods

trait Function1[A, B]{
	def apply (x: A) : B
}

e.g.
val func = (x:Int) => x +1
f(7)

will be translated into

val f = new Function1[Int, Int]{
	def apply(x:Int) = x+ 1
}

f.apply(7)

at run time

7. zip and unzip operators
merge two collections into a collection of tuples. Unzip is the other direction

8. for-yield expression

for (p <- persons if p.age > 20) yield p.Name

=

persons filter (p => p.age > 20) map (p => p.name)

inside for's brackets, it accepts a sequence of generators and filters
you can combine generator and filter in the order you like, as long as it starts with generator

e.g.

def scalarProduct(xs: List[Int], ys: List[Int]): Int =
	(for ( (x, y) <- xs zip ys) 
		yield x * y).sum

example of using a sequence of filters and generators:
find all authors that have written at least two books in the collection

for {
	b1 <- books
	b2 <- books
	if b1 != b2
	a1 <- b1.authors
	a2 <- b2.authoers
	if (a1 == a2)
} yield a1

for (x <- e1; y <- e2; s) yield e3 is translated to

e1.flatMap(x=> for( y<- e2; s) yield e3)

idea: for expression will work as long as the collection provides map, flatmap, and withFilter

LINQ has similar idea

		




