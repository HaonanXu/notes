List(1,2,3) zip s => to a pair
pairs.unzip => pair of two lists

(xs zip ys).map(xy => xy._1 * xy._2).sum

handle nested loop

(1 until n) map (i => ( 1 until i) map (j => (i, j))).flattern (
(xss foldRight Seq[int]()) (_ ++ _)

for (p <- persons if p.age > 20) yield p.name

for {
	i <- 1 until n
	j <- 1 until i
	if (isPrime(i+j)
} yeild(i, j)

(for ((x,y) <- xs zip ys) yield x * y).sum

e.g. 8 queens problem

queens(4) map show


for {
	booka <- books
	bookb <- books
	if ba.title < bb.title
	author <- ba.author
	ab <- bb.author
	if (a == ab)
	}yield a
	

val romanNumerals = Map("I" -> 1, 'V' -> 5, 'x' ->10)

options

partitions the collections into a map of collections with discriminator funciton f

groupBy (_.head) > map (p -> (pear, pineapple),
			a -> List(apple),
			o -> List(orange))
----------------------------
val  words = in.getLines.toList filter (word => word forall (ch=> ch.isChar)) //populate dictionary

val charCode: Map[Char, Char]=
	for ((digit, str) <- mnem, ltr <- str)) yield ltr -> digit

def wordCode(word:String): String = 
	word.toUppderCase map charCode

val wordsForNum: Map[String, Seq[String]] =
	words groupBy wordCode withDefaultValue Seq()

def encode(number:String): Set[List[String]] =
	if(number.isEmpty) Set(List())
	else
{
		for {
			split <- 1 to number.length
			word <- wordsForNum(number take split)
			rest <- encode(number drop split)
		}yield word :: rest
}.toSet

def translate(number:String) :Set{String]=
	encode(number) map (_ mkString " ")

notice: collection ops are tunes, can be parallelized
