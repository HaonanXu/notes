case classes: preferred way to define complex data
e.g.

abstract class JSON
case class JSeq(elems: List[JSON]) extends JSON
case class JObj (bindings: Map[String, JSON]) extends JSON
case class JStr(num: String) extends JSON
case object JNull extends JSON

val data = JObj (Map(
 "firstN" -> JStr("John"),
 "phone" => JSeq (List(JObj (JNull) )) 
))

def show(json: JSON): String = json match {
 case JSeq (elems) => "[" + (elems map show mkString ", ") + "]"
 case JObj(bindings)=> 
	val assocs = bindings map {
	case (key, value) => "\" + key + "\": " + show(value)
}//what is this case expression's type?
	"{} + (assocs mkString ", ") + "}"

case JNull => "null"
}

A type JBinding => String is a shorthand for scala.Function1[JBinding, String]

trait Function1[-A, +R] {
	def apply(x: A): R //the pattern matching block extends the apply
}

subclass function:
trait Map[Key, Value] extends(key => Value) //map function
trait Seq[Elem] extends Int => Elem //indexing

example:
f.isDefinedAt(List(1,2,3))

-----

abstract class List[+T] {
	def flatMap[U](f: => List[U]) : List[U] = this match {
	 case Nil => Nil
	case x:: xs => f(x) ++ xs.flatMap(f)

}

}

e1.map(x=>e2)
for  (x <- e1) yield e2

for(x<-e1 if f; s) yield e2
for (x<- e1.withfilter(x=>f); s) yield e2

for(x<-e1; y<-e2; s) yield e3
e1.flatMap(x => for (y<-e2; s) yield e3)

pat <- expr

x<- expr withFilter {
	case pat => true
	case _ => false
} map {
 case pat => x
}
