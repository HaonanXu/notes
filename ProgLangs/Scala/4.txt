traint intList[T]
{
	def isEmpty:Boolean
	def head: T
	def tail: List[T]
}

class Cons[T](val head: T, val tail:[T]) extends List[T]
{
	def isEmpty = false
}

class Nil[T] extends List[T]{

	def isEmpty = true
	def head: Nothing = throw new NoSuchElementException("message")
}

generic functions
def singleton[T] (elem:T) = new Cons[T](elem, new Nil[T])

but can use singleton(1) => implicit inferred

all type parameteres and type argumetns are removed before evaluating the prgram
type erasure

ex
def nth[T](n: Int, xs: List[T]) :T -
	if(n = 0) xs.head
	else nth(n-1, xs.tail)

e.g. implement simple boolean ops with ifthenelse[t](t;=>t, e;=>T) ;T

implement true, and false, < with ifthenelse

e.g. implement Succ(n:Nat) extends Nat w/o any primitive types

trait Function1[A,B]{
	def apply(x: A):B
}

so functions are objects with apply methods

thereare are also traits function2, 3...upto22

(x:Int) => x*x

class AnonFun extends Function1[Int, int] {
	def apply(x:Int) = x*x

but can apply be an instance of function as well?
}

e.g.

object(!!!!) List {
	def apply[T][x1: T, x2: T]: list{T] = new conts(x1, new xons(x2, new nil)
}

List(1,2)

two major type of polymorphism:subtypeing and generics
two major area: bounds and variances

e.g. assertAllPos taks an IntS
type bounds
def assertAllPos[S <: IntSet](r: S) : S

S is a sbutypoe of T S"> is a super type of T

can also Mix bounds

so its List[NonEmpty] <: List[IntSet], by covariance, its true

problem with covariant-array typing problem

evalutaiton of expression

non-solution: type testt and type casts
to avoid the "IsSubclassX" method problem
solution A: move eval to individual subclass

what if you want to simplify the whole expression? the simplification is non local

e.g. a * b + a * C -> a * (b + c)

intutition: the sole purpose of test and accessor funcitons is to reverse the construction process
while subclass was used
=> common siuttaion, automate it

object Numbr {
	def apply(n:Int) = new Number(n)
}

def eval(e:Expr):int = e match
{
	case Number(n)=> n
	case Sum(e1, e2) => eval(e1) + eval(e2)
}

trait Expr {
	def eval: Int = this mathc{
	}
}

pattenrs : ctors, variable, wilecar patterns, constants...

how eval sequence works

substitute e variable=> rewrite the whole line
