C++ uses "resource acquisition is initialization" idiom. When allocating a raw
resource, immediately pass it to an owning object.

This makes stack-based object with a resource-acquriing constructor and
resource-releasing destructor an excellent tool for automating resource
managemnet and cleanup

instead of calling a pair of OpenPort, ClosePort, you can

class Port
{
public:
	Port(strings const destination); //call OpenPort
	~Port(); //call ClosePort
};

void DoSomethong { Port port1("server1:80");}
----

be concisous of COPY ctor and Assignment => if ops dont make sense, make them
private and not defined. Otherwise, have copy constructor duplicate the
resource , and have the assignment operator do the same and ensure that it
frees its originally held resource if necessary (!!!)=> do NOT free the old
resource before the new resource is duplicated.

Prefer to hold dynamically allocated resources via smart pointers instead of
raw pointers.

perform every explicity resource allocation in its own statement that
immediately gives teh allocated resource to a manager object

e.g.

Fun (shared_ptr<Widget>(new Widege), shared_ptr<Widget>(new Widget));
=> if one ctor call throws an exception, then the other obj's memory will
never be released, because compiler might call 2 news first and then call the
2 ctors!

instead, do

shared_ptr spl(new Widget), sp2(new Widget);
Fun (sp1, sp2);

Raw pointers are fine in code where the pointed-to-object is visible to only a
restricted quantity of code, e.g., intenral to a class

Avoid const pass-by-val function parameters in fucntion declarations=>
redundant. But keep it in DEFINITION
-------

Avoid initializaiton dependencies across compilation units ....

Make header files self-sufficient

Always write internal #include guards
Never write external #include guards
