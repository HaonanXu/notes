Application components:
activity, service, broadcastreceiver, contentprovider.

Android instantiates and runs components as needed.
---
Activity: class for user interaction, usually implements a single, focused task that the user can do

example?
----
Service: runs in the background 
to perform long-running ops/ to support interaction with romote processes

example?
-----
BroadcastReceiver: listens for and responds to events
Subscriber in publish/subscribe pattern

Events represented by the Intent class and then broadcast=> BroadcastReceiver recives and responds

example?
----
Content providers: store & share data across app
Uses database-style interface
handles interprocess communication

example?

-----
Creating an android app: Define resources, Implement application classes, Package application, Install & run

-----
strings: /res/values/*.xml

<string anme="hello"> hello world! </string>

access by other resources as 
@string/string_name

accessed in Java as: R.string.string_name

-----

UI layout specified in XML files: res/layout/*.xml
R.layout.layout_name
@layout/layout_name

-----
At compilation time, resources are used to gen the R.java class
Java code uses the R class to access resources

--
class usually involves at least one activity. 
Activity initializaiton code usually in onCreate()

Typical onCreate() workflow:
Restore saved state
Set content view
Initialize UI elements
link UI elements to code actions
--------
System packages application components & resources into a .apk file
developers specify required application information in a file called androidmanifest.xml => applicaiton name, components, required permissions, application features, minimum API level

------
Eclipse run in the emulator, 
via command line: enable USB debugging on the device

---------
Activity: 
provides a visual interface for user interaction
Each activity typically supports one focused thing a user can do

Applications oftens has several activities

Navigation through activities: tasks, the task backstack, suspending & resuming activities

---
Task:
set of realted activities, which dont have to be part of the same app

Most tasks start at the home screen

When an activity is launched, it goes on top of the backstack
Whne the activity is destroyed, it is poppsed off the backstack

Android can kill activities when it needs their resources

---
Activity lifecycle states:

Resumed/running - bisible, user interacting
Paused - visible, not interacting, can be terminated
Stopped - not visible, can be terminated

Android announces activity lifecycle state changes to activity by calling specific activity methods

!!lifecycle graph here!!

-----

onCreate(): sets up initial state
call super.onCreate()
set the activity's content view
retain references to UI views as necessary
configure views as necessary

onRestart(): called if the activity has been stopped and is aobut ot be started again
special processing needed only after having been stopped

onStart(): Activity is about to become visible:
start when visible-only behaviors
loading persistent application state

onResume(): visible and about to start interacting with user
start foreground-only behaviors

onPause(): focus about to switch to another activity
shutdown foreground-only behaviors
save persistent state

onStop(): activity no longer visible to user (may be restarted later)
cache state.
May not be called if android kills your app

onDestroy(): release activity resources
May not be called if android kills your app
-------
starting activities:
create an intent object specifying the activity to start
pass the new intent to methods, e.g., startActivity()
startActivityForResult() (invokens a callback mehtod when the called activity finishes to return a result)

Started acitivity can set its result by calling Activity.setResult()

ResultCode(an int)
	RESULT_CANCELLED, _OK, _FIRST_USER,...

----------
Keyboard, orientation, localce, etc
Device configuration can change at runtime
on configuration changes, android usually kills the curent activity & then restts it

activity restarting should be fast
if necessary you can:
	retain an object containing important state information during a config change
Manulaly handle the config change

Hard to recompute data can be cached to speed up handling of configuration changes:
override on RetainNonConfigurationInstance() to Build & return config object
	will be called between onStop() and onDestroy()

call getLastNonConfigurationInstance() during onCreate() to recover retained object (fragment class is now the preferred way)

-------

can prevent system from restarting activity
declare the config changes your activity handles in
androidmanifest.xml

when configuration changes, activity's onConfiguraitonChanged() method is called
passed a configuration object specifying the new device configuration
