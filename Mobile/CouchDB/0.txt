every doc has a unique id
multi-version concurrency control with ACID semantics

data structured by views, Each view is a JS function that does Map. The function takes a document and transforms into a single value which it returns. can index views and keep those indexes updated and documents are changed. Views are defined with aggregate functions and filters are computed in parallel

multiple replicas can have their own copies of data, modify it,and then sync those changes later

All items have a unique URI with P/G/P/D as CRUD

so view computation lends itself to parallel and incremental computation. These functions produce key/value pairs, which can be inserted into the B-tree.

access documents and view results by key or key range => being able partition data over nodes=> BigTable, Hadoop, SimpleDB, memcached has similar things
If you want o change a value in a doc, you create an entire new verso of doc and save it over the old one=> end up with two versions of same document => a read request will always see the most recent snapshot of your database

Couch will pass the validation function a copy of the existing doc, a copy of the new doc, and additional information, such as authentication details, the validation function now can approve or deny the update

when two verison document conflict, the winning version is marked as the most recent version, losing version saved as previous version. Up to you the handle conflicts in a way that makes sense for your application. You can leave the chosen document version in place, revert to the older version, or try to merge the two version and save the result

initial backup -> reply with _rev 1 -> update with _rev1 -> Reply with _rev2

Forcing clients to hand back the correct document revision is the heart of CouchDB’s optimistic concurrency

-------

Assign your own UUIDs. Otherwise, you may make 2 POST because the first one
bombed out, you generate two docs and never find out the first one, because
only the second one replies, i.e., avoid duplicate documents

combination of a map and a reduce function is called a view. Reduce queires
are based on simple range requests against the indexes generated by map
funcitons

Map functions are called once with each document as argument. The function can
emit one or more view rows as k/v pairs. Primary goal is to build an index
that stores related data under nearby keys

When a map function fails regularly, Couch shuts off indexing the prevent
further resource usage. So it is important to check for the existence of any
fields before you use them,i.e.,

function (doc)
{
	var store, price, key;
	if(doc.item && doc.prices)
	{
		for(store in doc.prices)
		{
			price = doc.prices[store];
			key = [doc.item, price];
			emit (key, store);
		}
	}
}

-------
Sample request to server

PUT /db_name HTTP/1.1
User-Agent: ...
Host: ....
Accept: */*

Response

HTTP/1.1 201 Created
Server: ...
Date: ... (purely informational, shouldnt build any logic)
Content-Type: ...
Content-Length:...
Cache-Control: must-revalidate

Create doc with UUID
PUT http://host/db/GUID
and JSON in body

Response
HTTP/1.1 201 Created
Location: http://host/db/UUID
Etag: rev
and id and rev as JSON in body

let Couch generate UUID for you
GET http://host/_uuids

-------

To change doc in Couch, load full doc, make changes in JSON, and save the entire new revision of that doc. This also means when you update or delete, Couch expects you to know which revision you are going to change, or you will get "Document update conflict" error. The rev number is the md5 hash of the transport representation of a doc with an N-prefix denoting the number of times a document got updated.

Add attachment: _attachment in a body
PUT http://host/db/doc's UUID/attachmentname?rev=revNum
binary data in body

-----
Replication: notice the non-RESTness


