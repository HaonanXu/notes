every doc has a unique id
multi-version concurrency control with ACID semantics

data structured by views, Each view is a JS function that does Map. The function takes a document and transforms into a single value which it returns. can index views and keep those indexes updated and documents are changed. Views are defined with aggregate functions and filters are computed in parallel

multiple replicas can have their own copies of data, modify it,and then sync those changes later

All items have a unique URI with P/G/P/D as CRUD

so view computation lends itself to parallel and incremental computation. These functions produce key/value pairs, which can be inserted into the B-tree.

access documents and view results by key or key range => being able partition data over nodes=> BigTable, Hadoop, SimpleDB, memcached has similar things
If you want o change a value in a doc, you create an entire new verso of doc and save it over the old one=> end up with two versions of same document => a read request will always see the most recent snapshot of your database

Couch will pass the validation function a copy of the existing doc, a copy of the new doc, and additional information, such as authentication details, the validation function now can approve or deny the update

when two verison document conflict, the winning version is marked as the most recent version, losing version saved as previous version. Up to you the handle conflicts in a way that makes sense for your application. You can leave the chosen document version in place, revert to the older version, or try to merge the two version and save the result

initial backup -> reply with _rev 1 -> update with _rev1 -> Reply with _rev2

Forcing clients to hand back the correct document revision is the heart of CouchDB’s optimistic concurrency

-------

Assign your own UUIDs. Otherwise, you may make 2 POST because the first one
bombed out, you generate two docs and never find out the first one, because
only the second one replies, i.e., avoid duplicate documents

combination of a map and a reduce function is called a view. Reduce queires
are based on simple range requests against the indexes generated by map
funcitons

Map functions are called once with each document as argument. The function can
emit one or more view rows as k/v pairs. Primary goal is to build an index
that stores related data under nearby keys

When a map function fails regularly, Couch shuts off indexing the prevent
further resource usage. So it is important to check for the existence of any
fields before you use them
