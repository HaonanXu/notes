Very important to consider the logout scenario! If revoking the permissions is needed, then only a single request to the API Gateway will be provided, then the API Gateway can kill the session for that user.

separate authen and authorization filter

OAuth 2 client credentials grant is designed for communications between services. Authentication for client credentials grant typically involves passing a shared secret,
bearer token is normally some kind of secret value created by the authentication server. It isn't random; it is created based upon the user giving you access and the client your application getting access.

Refresh tokens are stored in DB and will have long expiration (example: 1 month).

A user can get a new access token (when it expires, every 30 minutes for example) using a refresh token, that the user had received in the first request for token. When an access token expires, the client must send a refresh token. If this refresh token exists in DB, the server will return to the client a new access token and another refresh token (and will replace the old refresh token by the new one).

The  Authorization: <type> <credentials> pattern was introduced by the W3C in HTTP 1.0,

After the access_token expires, an active refresh_token can be used to get a new access_token / refresh_token pair as shown in the following example. This cycle can continue for up to 90 days after which the user must log in again. If the refresh_token expires, the tokens cannot be renewed and the user must log in again.

POST /login/refreshToken HTTP/1.1 - note that the refresh token returned will be different!

The information is signed with either a secret (using an HMAC) or a public/private key-pair using RSA

Authorization header is not a simple header, hence a pre-flight request would be required for all the requests to a particular URLs.

But this happens if you are sending Content-Type: application/json for instance. So this is already happening for most applications.

One small caveat, the OPTIONS request won't have the Authorization header itself, so your web framework should support treating OPTIONS and the subsequent requests differently

---------
The Authorization Code Flow goes through the following steps.

Client prepares an Authentication Request containing the desired request parameters.
Client sends the request to the Authorization Server.
Authorization Server Authenticates the End-User.
Authorization Server obtains End-User Consent/Authorization.
Authorization Server sends the End-User back to the Client with an Authorization Code.
Client requests a response using the Authorization Code at the Token Endpoint.
Client receives a response that contains an ID Token and Access Token in the response body.
Client validates the ID token and retrieves the End-User's Subject Identifier.
-----------

Microservices should be stateless, which means no sessions. You should pass the auth details each time instead of using a cookie/session.

Managing it at the microservice level is definitely a simpler and more straight forward approach. For us, the reason why we chose a central authorization is because we want to be able to create new permissions and map them to endpoints directly via a UI. This is especially important since we have different apps that might be accessing the same endpoints and different permissions will need access to those endpoints.

---------
In fact, much of the point of OAuth is about giving this delegated access for use in situations where the user is not present on the connection between the client and the resource being accessed. This is great for client authorization, but it's really bad for authentication where the whole point is figuring out if the user is there or not (and who they are).

the core functionality of OAuth remains intact, and what's happening is that the user is delegating access to their identity to the application they're trying to log in to. The client application then becomes a consumer of the identity API, thereby finding out who authorized the client in the first place.

Authentication is more like fudge. There are at least a few ingredients that must brought together in the right way to make it work, and OAuth can be one of these ingredients (perhaps the main ingredient) but it doesn't have to be involved at all.

And in fact, there are a number of well-known recipes out there for doing this with specific providers, like Facebook Connect, Sign In With Twitter, and OpenID Connect (which powers Google's sign-in system, among others). These recipes each add a number of items, such as a common profile API, to OAuth to create an authentication protocol.


Common pitfalls for authentication using OAuth
1. Access tokens as proof of authentication. 
 This problem stems from the fact that the client is not the intended audience of the OAuth access token. Instead, it is the authorized presenter of that token, and the audience is in fact the protected resource. The protected resource is not generally going to be in a position to tell if the user is still present by the token alone, since by the very nature and design of the OAuth protocol the user will not be available on the connection between the client and protected resource. To counter this, there needs to be an artifact that is directed at the client itself. This could be done by dual-purposing the access token, defining a format that the client could parse and understand. However, since general OAuth does not define a specific format or structure for the access token itself, protocols like OpenID Connect's ID Token and Facebook Connect's Signed Response provide a secondary token along side the access token that communicates the authentication information directly to the client. This allows the primary access token to remain opaque to the client, just like in regular OAuth.

2. Access of a protected API as proof of authentication

Since the access token can be traded for a set of user attributes, it is tempting to think that posession of a valid access token is enough to prove that a user is authenticated. This assumption turns out to be true in some cases, where the token was freshly minted in the context of a user being authenticated at the authorization server. However, that's not the only way to get an access token in OAuth. Refresh tokens and assertions can be used to get access tokens without the user being present, and in some cases access grants can occur without the user having to authenticate at all.

Furthermore, the access token will generally be usable long after the user is no longer present. Remember, since OAuth is a delegation protocol, this is fundamental to its design. This means that if a client wants to make sure that an authentication is still valid, it's not sufficient to simply trade the token for the user's attributes again because the OAuth protected resource, the identity API, often has no way of telling if the user is there or not.

3. Injection of access tokens


4. Lack of audience restriction

5. Injection of invalid user information

6. Different protocols for every potential identity provider

----------

Google Cloud Endpoints handles both API keys and authentication schemes (such as Firebase or Auth0). The main distinction between these two is:

API keys identify the calling project — the app or site — making the call to an API

Auth tokens identify a user — the person — that is using the app or site
