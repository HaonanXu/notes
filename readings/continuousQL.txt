example: stream (with sliding window) to relation join

stream to relation: window spec lang
relation to relation: SQL
relation to stream: 3 special operator

how plans are selected, how they adapt and migrate over time?

section 10: GSQL vs CQL

procedural vs declarative: aurora

Each stream and relation has a fixed schema

Steram is a bag of elements (s, r), where s is a tuple with a schema, and r timestamp
Relation is a map from T to a finite but unbounded bags of tuples within the schema of R

model "current # of vehicles in a segment" is a time-varying relation rather than a stream of latest values

stream-to-stream operator is composed from operators of the 3 classes above

continuous semantics: result of continous query Q at time r => result of Q once all inputs up to r are available,  the result is S up to r or R(r)

semantics does not indicate liveness of the of CQ output-> latency management in query processor handles it
--------

potential problem: to filter a stream => turn s to r, filter on r, and then turn r to s => use defaults and syntactic shortcuts

s-to-r: sliding window over a stream, time-based, tuple-based,partitioned, now, unbounded

output R of S [Range T]
R(r) = {s | (s, r') in S && r' <= r && r' >= max(r-r', 0)

partitioned windows: logically partition S into different substreams based on equality of attributes, pretty much sql group by

r-to-s:insert/delete/relation stream
IStream(r) = ForAll(r>0)(R(r) - R(r-1) * {r}) => filter with unbound, stream slide window join
DStream(r) = ForAll(r>0)(R(r-1) - R(r) * {r})
RStream(r) = ForAll(r>0)(R(r) * {r}) => filter with now, stream window-relation join

Q: express DStream and IStream with RStream and timed-based sliding windows and relational ops

example: all entries in the stream > 65, IStream and RStream version

Unbound window by default

Default R-to-S Operators
outermost query: IStream the query produces monotonic relations
inner subquery: IStream for monotonic subquery

--------
Little Road example in CQL

-------
check SW03 for time management implementation

heartbeat: no message after > is accepted. To generate heartbeat:
generated by DSMS clock
source hearthbeat: need to ensure within each stream heartbeat and the stream elements reach DSMS in timestamp order
properties of streams/systems/network enviroments or a subset of them

--------
window reduction

filter-window commutativity

silding-window join with an Istream operator

Stream-only query language
-----
interally use tagged tuple:timestamp + insertion or deletion, append-only, nondecreasing timestamp, use heartbeat to handle out of order
arrival

query plan is merged: operators, queues, and synopses

synoposes: owned by a single operator=> materialize current state of a relation, or approximate query answering

page 23: catches

page 26: crude query optimization
