For enterprise integration patterns, a message consists of 2 basic parts: Header and body

place all messages supported by a given actor type in the source module along with the definition of the receiving actor
or
place all common message types into one Scala source file.

useful if the types will be used across remote actor systems and the message types must be deployed and used for either sending or receiving
on the multiple systems,e.g., group them in companion objec

you can extend all Messages from a sealed trait, which supports a special protection when matching. you can enforce that attempts to match any one of the case classes will require the programmer to match on all of them. Yet, it does require
you to use a nested match construct. => compiler will warn unexhaustive matching
=>
a Canonical Message Model (333) based on case classes will need to be redeployed on every system as the types change.

A different approach:
 the use of text-based messages formed as JavaScript Object Notation (JSON) weak schema and on-the-fly typesafe parsing when received. The
message contract is conveyed using a Published Language [IDDD] that is designed as a REST custom media type. By both sides of the messaging
integration adhering to the Published Language, messages can be exchanged in this way without the need to distribute or generate message
type classes on the receiver side. You may, thus, find it helpful to use message type versions distinguished by Format Indicator (222) so
you can support multiple dependent actor systems at the same time. This will be especially helpful when messages are exchanged between
actors and nonactor systems

When using Message Bus (192), another design consideration is to include a set of bus-level messages that carry application-level messages
around the bus. =>i.e., Any time payload

all of the filter actors in the pipeline, other than the first, receive the same standard message

each filter actor, other than the last, is given the next filter in the pipeline as a constructor argument. Both of these design decisions
allow for any of the filers other than the last to be rearranged in the pipeline, or completely replaced, and for new filters to be added as
needed.

awaitCompletion()


he Message Router itself can be an actor. The router actor is placed somewhere appropriate in the processing pipeline. When the router
receives a message, it checks the conditions specified by its contract and dispatches the message to the appropriate actor based on those
conditions. It really doesnâ€™t matter how many potential actors there are to which the router may route the message, just that there is one
actor to fulfill each possible routing condition.

 the outcome of a Command Message may well be an Event Message 

When translated by the receiving system, the event becomes a command and is dispatched to the local Application Services.

the integrated receiver of the Message (130) will be a Message Endpoint (145) actor. The endpoint may use another actor as the primary
translating adapter, with the understanding that the transformation will be completed asynchronously. 




