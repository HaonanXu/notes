def map2[A,B,C](ma: F[A], mb: F[B])(f: (A,B) => C): F[C]

Appliacative functor: map2 and unit are primitive

because map can be implemented by map2, applicative itself is a functor
because map2 can be implemented by flatmap, all monads are applicative functors

th Applicative, the structure of our computation is fixed; with Monad, the results of previous computations may influence what computations
to run next,i.e., Applicative composes, monad does not

Either monad vs Either applicative

type constructors = effect: augment regular values with extra capabilities

-----
functor laws

map(v)(id) == v
map(map(v)(g))(f) == map(v)(f compose g)

-----
for Applicatives

map2(unit(()), fa)((_,a) => a) == fa
map2(fa, unit(()))((a,_) => a) == fa

-----
associativity laws for monoids and monads
op(a, op(b, c)) == op(op(a, b), c)
compose(f, op(g, h)) == compose(compose(f, g), h)

associative law for functor:
product(product(fa,fb),fc) == map(product(fa, product(fb,fc)))(assoc)

Neutrality law
map2(a,b)(productF(f,g)) == product(map(a)(f), map(b)(g))

def productF[I,O,I2,O2](f: I => O, g: I2 => O2): (I,I2) => (O,O2) =
  (i,i2) => (f(i), g(i2))
-----

trait Traverse[F[_]] {
  def traverse[G[_]:Applicative,A,B](fa: F[A])(f: A => G[B]): G[F[B]] =
    sequence(map(fa)(f))
  def sequence[G[_]:Applicative,A](fga: F[G[A]]): G[F[A]] =
    traverse(fga)(ga => ga)
}

difference between traverse and fold(Map): tranverse preserves teh orginal structure

----

Using a State action to traverse a collection, we can implement complex traversals that keep some kind of internal state.

But if G also happens to have a Traverse instance, we can sequence to turn G[F[_]] into F[G[_]], leading to F[F[G[G[A]]]]. Then we can join
the adjacent F layers as well as the adjacent G layers using their respective Monad instances.

The issue of composing monads is often addressed with a custom-written version of each monad thatâ€™s specifically constructed for
composition. This kind of thing is called a monad transformer. 
