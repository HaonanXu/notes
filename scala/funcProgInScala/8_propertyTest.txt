Property-based testing
specifying behavior of the problem and give constraints, framework then generate test cases satisfied these constarints

function forAll creates a proprtied by combining with a generator with sig A => Boolean, i.e., all values produced the generator should
satisfied the predicate

properties can be glued via &&

on failure, framework will try to figure out smallest failed small case possible, by trying to minimize test case step by step

can try exhausitve generation and test

Design process
1. We need Gen[A], basic generator
2. Gen.listOf : Gen[A] => Gen[List[A]] here we want to stay within our API algebra for as long as we can
3. probably need a Gen.listOfN (Gen[A], int) => Gen[List[A]], so we can specify size
4. by the definition of property, we will have

forAll(Gen[A]) (A => Boolean) : Prop //Notice we try to stay within the algebra again!

5. We want to glue/combine properties together, this means Prop will have && op of type 
Prop => Prop (another to combined)

6.Proprty need a check function to actually run tests, and check should return either succes or failure information

Seems we can not carve more info out of prop, let's move back to Gen

Gen needs state info to help generation, i.e.A State[RNG, A], where State is S => (A, S)

Useful propertyes, generation of [A, B] where B depends on the value of A, need flatMap

Union(Gen[A], Gen[A]): Gen[A], pull them with equally likehood, and similarly, weighted

For prop: how many cases to pass before we show the result: TestCase => Result, 
need to pass additoinal dependency to Prop.run

Introduce SizedGen(int => Gen[A])

Gen.listOf : returns SGen

----

A property test for parallel computation

introduce proved to handle ignored test case


--------
def listOf[A](a: Gen[A]): Gen[List[A]]

def forAll[A](a: Gen[A])(f: A => Boolean): Prop

trait Prop { def &&(p: Prop): Prop }

object Prop {
  type FailedCase = String
  type SuccessCount = Int
}
trait Prop {
  def check: Either[(FailedCase, SuccessCount), SuccessCount]
}

case class State[S,A](run: S => (A,S))

case class Gen[A](sample: State[RNG,A])

def choose(start: Int, stopExclusive: Int): Gen[Int] = Gen[Int](RNG => (Int, RNG))

def unit[A] (a :=> A) : Gen(A) = Gen(RNG => (a, RNG))
def boolean: Gen[Boolean] = Gen(RNG =>(bool, RNG))
def listOfN(n : Int, g: Gen[A]): Gen[List[A]] = Gen(RNG => (List[A], RNG))

def flatMap[B](f: A => Gen[B]): Gen[B] = RNG => (f(sample.run(RNG)._1)).sample.run(RNG)

def listOfN(size: Gen[Int]): Gen[List[A]] = size.flatMap (n => listOfN(n, Gen[Int]))

def union[A](g1: Gen[A], g2: Gen[A]): Gen[A] = boolean.flatMap (first => if (first) g1 else g2)

def weighted[A](g1: (Gen[A],Double), g2: (Gen[A],Double)): Gen[A]


