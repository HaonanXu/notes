ActorRef: suppoert seding messages to the actor it represents. Each actor has
access to itself through self

Purely local actor references: will not function if sent across a network
connection to a remote JVm

Local actor references when remoting is enable are used by actor systems which
support netowrking functions for those reference which represent acots within
the same JVM. Also include protocol and remote addressing info

actors mixing in the Router: sending a message to them dispatchs to one of
their children directly

Actor -> ActorCell -> ActorRef -> ActorPath

speical types of actor reference:
PromiseActorRef, DeadLetterActorRef, EmptyLocalActorRef, DeadLetterActorRef

Actor path represents a name which may or may not be inhabited by an actor adn
the path itself does not ahve a lifecycle. Messages  sent to the old actor
reference will not be delivered to the new incarnation even though they have
the same path

A physical actor path never spans multiple actor systems or JVMs

ActorSystem.actorOf returns a reference to the newly created actor. each actor has direct access to referenmces for is parent, itself,a nd its children. References may be sent within messages to other actors so you can reply directly

Actor references may be lookied up using the ActorSystem.actorSelection. To acquire an ActorRef, send a message such as identify message, tot he actor and use the sender reference of a reply from the actor

ActorSystem.actorSelection vs ActorContext.actorSelection

* and ? can be used in context.actorSelection and broadcast

context.actorSelection("../*") ! msg => but impossible to watch a seleciton for liveliens changes, have to sedning a requesnt and gather all answers, extractly the sender references, and then watch all discovered concrete actors

actorOf only creates a new actor, a direct child of the cotnxt
actorSelect only looks up exisitng actos, does not even verify existenc of actors when the selection is created

When an actor is terminated, DeathWatch will publish its final transition and it is not expected to come back to lifea => create an actor at a later time with an idential path is not a good practice.

Whent he test subject depends on being instatiated at a specific path => Mock its supervisor so it will forward the Terminated msg to the appropriate point, enabling the latter to await proper deregistration of the name

context.parent and context.path.parent do not represent the same actor when actor is created remotely. Looking up the child's name within the supervisor will find it on the remote node

/user: guardian actor for all user-created top-level actors
/system: guardian actor for all systme-created top-level actors
/deadLetters: all messages sent to stopped or non-exisitng actors
/temp: short-lived system-created actors
/remote: all actors reside whose supervisors are remote actor references

----------

Closures used as actor factories if actor is created on a remote node needs to be serializable. Everything needs to be aware of all interactions being fuly asynchronous

Not possible to safely create pure C-S setups with predefined roles => use HTTP or Akka I/O

Useing setups involing Network Address Translation, Load Balancers or Docker containers violates assumptin 1 UNLESS network configuraiton allows symmetric communication between systems => how?

do NOT close over non-final fields, otherwise they must be marke volatile so the current value of the field is visible to the callback

if close over a reference, the instance needs to be thread safe

anti-pattern: closeing over internal Actor state and exposing it to other threads

e.g., you see state variables, sender, inside Future

Correct way: use Future's onComplete and close over self, which is a thread-safe ActorRef

keep sender in a val and use that val in sendder => we close over a fixed value and it's an actor ref, which is thread-safe

messages should be immutable for thread safety => that is why you use case class
