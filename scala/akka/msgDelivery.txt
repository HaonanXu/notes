at-most-once delivery
mesage ordering per sender-receiver pair: messages sent direclty form the frist to the seocnd will not be received out-of-order

Fiaulre of a child of an actor is communciated by speical system messea that are not ordered relative or ordinary user messages

Akka Persistence moduel for at-least-once delivery

deadLette3rs main use is for debugging => try not to sendng to deadLetters where possible i.e. run application with suitable dead letter logger

actor can subscrib DeadLetter on the event stream. Dead letters are not propagated over the network, you end subscribe and forwad them manually.

Eveyr tiem an actor does not termiante by its own, chances are soem messages which it sends to itself are lost. This is ususally benign

---------

Configuration part skipped

---
akka.actor.UndahelndMEssage will be published to ActorSystem's EventStream

Props config class to sepecify options for the creation of actorks

val props = Props(new MyActor) //BAD! because it encourssages to close over the enclose scope, and Props is non-serializable
val probps1 = Props[MyActor]
val probps2 = Props(classOf[ActorWithArgs], "arg")

Declareing one actor witin another is dangerous. Never pass an actor's this into Props!

Good practice:

1.provide factory methods ont he companion object of each Actor. This keeps the creation of Props and avoids Props.apply, since within a companion object the given code block will not ratain a reference to is enclosing scope

object DecoActor{

def props(num: Int): Props = Props(new DemoActor(num))
}

class DecomActor(num :Int) extends Actor{
def receive = ...
}

class OtherActor extends Actor{
	context.actorOf(DocmoAcotr.props(42), "demo")
}

2. Declare what msgs an Actor can receive in the companion object of the Actor

3. ActorSystem is a heavy object, create only one per application. Use ActorSystem to create top-lvel actors, using an actor's context creates a child actor

4. name you actors, since that is used in log messages and for identifying actors => duplciate name triggers InvalidActorNameException

------
Use Akka with Dependency Injection

----

Writing code outside of actors which shall communicate with actors, can use the ask pattern. But to receive multiple replies and watch other actor's lifecycle => use Inbox class

Restart and resume of an actor is within the same incarnation, but stop will bring another incarnation

class WatchActor extends Actor {
	val child = context.actorOf(Props.empty, "child")
	context.watch(child) //register for DeathWatch
	var lastSender = system.deadLetters

	def receive = {
		case "kill" => 
			context.stop(child)
			lastSender = sender
		case Terminated('child') => lastSender ! "finished"

	}

}
----
preStart hook
preRestart/postRestart hook
postStop hook
--------

Always preferable to communicate wiht other Actors using ActorRef instead of relying upon ActorSelection, exceptions: 
using at-least-once delivery facility
initiating first contact with a remote system

Get ActorRef for an ActorSelection: use of Identify message

!: send a message asynchly and retur immediately
?: sends a emsage async and restusn a Future repesenting a possible reply

implicit val timeout = Timeout(5 seconds) //needed for ?

val f = 
for {
	x <- actorA ? Request.mapTo[Int]
	s <- actorBG ? Request.mapTo[String]
	d <- (actorC ? Request).mapTo[Double]
} yield Result(x,s,d)

f pipeTo actorID  //To complet eh fure witha n exeption you need send a Fialure message to the sender. This is NOT done automatically when actor 

try{

}catch {
	case e: Execption =>
		sender ! akka.actor.Status.Failure(e)
		throw e

}

onComplete, onSuccess, onFailure can used to register callback => but avoid closing over the containing actor's reference! do call method or access mutable stqate on the actor from within

forward message

gracefulStop to wait for termination or compose ordered termination of actors

-------

become taks a ParitialFunction[Any, Unit]. The hotswapped code is kept in a Stack which can be pushed and popped. Actor will revert to its original behavior whne restared by its Supervisor

Stash trait to temparily stash away mesags that can not or should not be handled using the actor's current behavior

Kill vs PoisonPill

If an exception is thrown while msg is being processed, this message will be lost, you need to catch and try yourself => or use PeekMailbox pattern

Extending Actos with PartialFunction chaining or else's partial funcitonf9!)

trait B
trait A { this: B => }

A cannot be mixed into a concrete class that does not also extend B

Init via constructor: construct is invoked for eveyr incarnation of the actor, but when you want to avoid reinitalize internals on restart?e.g., preserve child actors

Initilziatoin via prestart
