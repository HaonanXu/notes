source code of the project inside activator, then ./activator run

Common use cases:
1.regular JAR on the classpath, most likely if you are build web app
2.stand alone appl by instantiating ActorSystem in a mainclass or using the Microkernel

Production cases:
1.Transaction processing
2.Service REST etc as message hub /integration layer
3.Concurrency/parallelism
4.Simulation: master/worker, MapReduce
5.Camel integration to hook up with batch data source divide and conquer the workloads
6.Communications hub
7.Event stream processing

Each actor has exactly one supervisor, which is the actor that created it

If one actor does not ahve the means for daelin with a certain situation, it
sends a corresponding failure message ot its supervisor, asking for help =>
layered design wich devloves into defensive programming with teh aim of not
leaking any failure out

Hierarchy design guideline:
1.If one actor manages the work another actor is doing,e.g., by pasing on
sub-tasks
2. if one actor carries very importatnt data, this actor should source out any
dangerous sub-tasks to children it supervises and handle failures => Error
Kernel pattern, create a new child for each request
3.If one actor depends on noather actor  for carrying otu itsduty, it shoudl
watch that other actor's liveness and act upon receiving a termination notice
=> This is NOT supervision, because the watching party has no influence on the
supervisor strategy

Actor best practices:
1.actors should nto block unless it is unavoidable
2. Do not pass mutable objects between actors
3. No routinely send behavior within messages,e.g., by using Scala closure
4. Top-level actors are the innrmost part of your Error Kernel, create them
sparingly and prefer tryy hierachical systems => guardian actor is a single
point of contention if over-used

When blocking is unavoidable
1. Do the blocking call within an actor, make sure to configure a thread pool
which is either dedicated for this purpose  => e.g. create a router for N
actor, each of which wraps a single DB connection and handles quereis as sent
to routner
2. Do the blcoking call within a Future, ensuring an upper bound on the # of
such calls at any point in time
3.Do the blocking call within a Future, prodiving a thread pool with an upper
limit on the # of threads 
4. dedicate a single thread to manage a set of blocking resources and dispatch
events as they occur as actor messages

-------------

Actors are represented to the outside using actor references, which are
objects that can be passed around freely and without restriction => restarting
an actor without needing to update references elsewhere, placing the actual
actor object on remote hosts, sending messages to actors in completely
diffrent applications AND local state isolation

State: FSM module, counter, listeners, pending requests... 
When the actor fails and is restarted by its supervisor, the state will be
created from scratch. A restart of the actor will reset its behavior to this
initial one

Sending multiple messages to the same traget formt he same actor will enqueue
them in the same order. Current behavior must always handle the next dequeued
emssage. Failure to handle a message is typically treaed as failure

List of children is within context. Modifications tot he lsit are done
context.actorOf or context.stop(child)

Supervisor strategy cannot be changed once an actor has been created,i.e.,
children with different supervisor strategy should be grouped and divided
together

When an actor dies, drain all messages from itsmailmbox into the systems' "dead
letter mailbox" => EventStream as DeadLetters. Do NOT rely on it to construct
"guaranteed delivery"

-----

Options for supervisor to handle failure
1.Resume the subordinate, keeping its accumulated internal state 
resmues all its subordinates
2.Restart the subordinate, clearing out its accumulated internal state
3. stop the subordinate permantnly
4. Escalate the failure, thereby failiing itself

Notice restart/stop will affect all decedents as well

Each supervior is configured witha  function traslateing failure causes into
one of the 4 options => if you feel not flexible, because translation doesnt
accept actor identity as input, problably need another level
of supervision 

In general, teh user cannot influence the order of normal messages and failure
notifications

-----
An actor system during creation start at least 3 actors

/user: guardian actor, parent of all user-careed actors: system.actorOf. When
guardian actor escalates a failure, the root guardain's response will be to
terminate the guardian, which in effect will shut down the whole actor system

/system: system guardian. Ensure an orderly shut-down sequence where logging
remains active whil all normal actors terminate, even though logging itself is
done by actors

/: root guardian

sequence of actions during restart
1. suspend the actor, and recursively suspend all children
2. call the old instance's preRestart (defaults to sending terminate request
to all children and calling postStop)
3. wait for all children which were requested to terminate during preRestart.
The termincate notice form the last killed child will effect the progression
to the next step
4.create new actor isntance by inovking the original factory
5. call psotRestart on the new instace (which by default also calls preStart)
6. restart all chilred not killed in 3, each children recursively follow steop
2
7. resume the actor

--------

Monitoring ties one actor to another so taht it may react to the otehr actor's
terminate, in contrast to supervision which reacts to failure

Lifecycle monitoring is implemented using a Terminated message to be received
by the monitoring actor, where the dault behavior is to throw a special
DeathPactException => use ActorContext.watch(targetActorRef) and unwatch to
stop listening

useful if a supervisor cannot restart its children and has to terminate
them,e.g., actor inialization failure, it should monitor children and
re-create them or schedule itself to retry later

an actor needs to fail in the absense of an external resource, which may also
be one of its own children. If a theird party terminates a child or
system.stop or PoisonPill, the supervisor might well be affected

OneForONeStragtey: applies the obtained directive only to the failed child
AllForONeStragtey: applies to siblings as well. applicable where the ensembel
of children has such tight dependency. Stopping a child will NOT termnicate
other children => implement by watch children lifecycle

problem of creaign one-off actors from an all-for-one supervisor








