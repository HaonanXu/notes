trait Apply[F[_]] extends Functor[F] { self =>
  def ap[A,B](fa: => F[A])(f: => F[A => B]): F[B]
}

trait Applicative[F[_]] extends Apply[F] { self =>
  def point[A](a: => A): F[A]

  /** alias for `point` */
  def pure[A](a: => A): F[A] = point(a)
}

<*>, <*, and *>

monoid: associativive binary function and an identify value with respect to that function

trait Semigroup[A]  { self =>
  def append(a1: A, a2: => A): A
}

Ordering as Monoid!

two functor laws: identify and associative composing order => use functorLaw to check/test
---------

Monad[Option].point(Pole(0, 0)) flatMap {_.landRight(2)} flatMap {_.landLeft(2)} flatMap {_.landRight(2)}

Say you have a chess board and only one knight piece on it. We want to find out if the knight can reach a certain position in three moves.

monad laws:
(Monad[F].point(x) flatMap {f}) assert_=== f(x)
(m forMap {Monad[F].point(_)}) assert_=== m
(m flatMap f) flatMap g assert_=== m flatMap { x => f(x) flatMap {g} }

 implicit class PairOps[A, B: Monoid](pair: (A, B)) {
         def applyLog[C](f: A => (C, B)): (C, B) = {
           val (x, log) = pair
           val (y, newlog) = f(x)
           (y, log |+| newlog)
         }
       }

def logNumber(x: Int): Writer[List[String], Int] =
         x.set(List("Got number: " + x.shows))

def multWithLog: Writer[List[String], Int] = for {
         a <- logNumber(3)
         b <- logNumber(5)
       } yield a * b

def gcd(a: Int, b: Int): Writer[List[String], Int] =
  if (b == 0) for {
      _ <- List("Finished with " + a.shows).tell
    } yield a
  else
    List(a.shows + " mod " + b.shows + " = " + (a % b).shows).tell >>= { _ =>
      gcd(b, a % b)
    }

ot functions are applicative functors. They allow us to operate on the eventual results of functions as if we already had their results.

val addStuff: Int => Int = for {
         a <- (_: Int) * 2
         b <- (_: Int) + 10
       } yield a + b

stateful computation: s -> (a, s)

 object State extends StateFunctions {
    def apply[S, A](f: S => (S, A)): State[S, A] = new StateT[Id, S, A] {
      def apply(s: S) = f(s)
    }
  }

State[List[Int], Int] { case x :: xs => (xs, x) } //so state wraps a function!

val pop: State[Stack, Int] = for {
         s <- get[Stack]
         val (x :: xs) = s
         _ <- put(xs)
       } yield x

def push(x: Int): State[Stack, Unit] = for {
         xs <- get[Stack]
         r <- put(x :: xs)
       } yield r
---------

Either[A,B] context of failure to values while bing able to attach values to the failure. Note that scala Either is not a monad

 "boom".left[Int] >>= { x => (x + 1).right }

 "event 1 ok".right | "something bad" // | is getOrElse

~"event 2 failed!".left[String] | "something good" // ~ is swap

 "event 1 failed!".left ||| "retry event 1 ok".right // ||| is orElse

-------
Valdiation: not a monad, but it's an applicative functor,i.e., can't chain events, it iwll just validate all of them
