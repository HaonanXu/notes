parametric polymorphishm: value's type contains one or more type variables

subtype polymorphism: define a trait, and use it as type upperbound of type param. Problem is that for any type has to include this mixin in
declaration. Inconviniet, and worse, impossible for pre-packaged types

ad-hoc polymorphism:implicit conversion or implicit parameters

monoid: mapend: combine 2 to produce another type and mzero: produce a zero,i.e., we create an IntMonoid which implements Monoid[Int]

process: from concrete sum function on ints, to sum fuction accept a list and monoid

instead of implicit parameter, you can use context bound implicitly

NOTE: we dont need to define types, use val varName = new Monoid[A] {
  def ...
  def ..
}

pattern, and put them in a companion object of the trait

abstract foldLeft,i.e., instead of list.foldList, use FoldLeft(list, moinid)

and foldLeft can be abstract into a Fold[F[_]] trait, similarly, concrete FoldLeft implementaiton will be a context-bound implicit variable
defined in the companion object

Method injection:

create an Op trait that includes monoid, with your operator defined. 
add an implicit conversion from primitive type to your Ops type, with Monoid coming in as implicitly. This is how scalaz injects new
methods!

trait MonoidOp[A] {
         val F: Monoid[A]
         val value: A
         def |+|(a2: A) = F.mappend(value, a2) //of form val |+| a2
       }

M[A] to A[M]

e.g. 
(1 > 10)? 1 | 2
1.some | 2

------
Eq type class: === and =/=, => fail to compile

1 assert_=== 2

-----
Order

1 gt 2.0
1.0 ?|? 2.0
1.0 max 2.0
-----
show

---
Enum: types in list ranges

---
or type case objects extend from a single trait

----
Functor type class: things that can be mapped over:

Functor instance for functions, i.e., a way to compose function:

(a -> b) -> (r -> a) -> (r ->b) 

-----
Applicative: extends from Apply

pure. Take a value,and return an applicative value that gives the same value with minimal context

----
Apply: extends Functor

def ap[A,B](fa: => F[A])(f: => F[A => B]): F[B]

aliases to <*> 

<*, *> will take only left or right side

none *> 2.some will give none!

3.some <*> { 9.some <*> {(_: Int) + (_: Int)}.curried.some }

^(3.some, 5.some) {_ + _}

^(3.some, none[Int]) {_ + _}

-----
List type contructor, [] are applicative functor
-----
kind type of type

first-order value => type
first-order kinded type => type that accepts other types to create a proper type => i.e., type constructor

tagged class

Ordering as monoid: use case

------
def lengthCompare(lhs: String, rhs: String): Ordering =
         (lhs.length ?|? rhs.length) |+| (lhs ?|? rhs)

-----
functor laws: identify and associative composition

applicative laws: skip detail

semigroup laws: associative

monoid law: identify value to LHS or RHS

 Monad[Option].point(Pole(0, 0)) flatMap {_.landRight(2)} flatMap {_.landLeft(2)} flatMap {_.landRight(2)}
