Context:
We have different service processes across many servers. We want to monitor states
of these services in a centralized place. Note user should be able to define what internal state is "interesting",i.e.,
this definition is specifc to each type of services. Generic health information is not enough

Problem
Do we allow user to define monitoring rules specifc to each service from our centralized
monitor?

Discussion:
1.Should those processes know the existence of our monitor?
Yes. If not, 
A. the public info they expose may not directly relate to the status
we are going to monitor, which is very likely given number of services our
monitor will handle in the future
B. Or our monitor has to tranlsate the public stats into ones interesting to user

2.how much information should we expose to those processes?
A. We expose our monitoring service API, and other services have to explicitly
use it => possible 
B. We force other services to expose certain, monitoring specific API to us =>
interface coupling => NO
C. We force other service to expose generic API that could be used for
monitoring purposes => reasonable since they want that to be monitored

3. How do we define the monitoring rules, espeically it is very process-type-specific?

A. on process's side
Client service will preprocess the data and post the result to us.
To visualize the rule, need to ask client to push the rule to us => coupling of API

B. on our monitor's side
Polling: need to know the channel/API to poll via rules=> our monitor needs to know the every single app it interests
Pushing: need to send rule over to client. so client knows which data to push => coupling of client's API with ours, BAD

C. neither: third party
In effect, a dispatcher in publisher/subscriber model, a compromise of the first 2 options.

4.How do we "visualize" the rules?
Because our monitor, which has only access to public data, has knowledge of rules, the actual state must be exposed
to us, i.e., from our monitor, the rule should be simple API call(s) to client
service. That also means our monitor does as little domain-specfic
computation as possible

5.How do we transfer the computation result of the rules?
Polling: easy given our definition of rules, i.e., one API call with parameters.
Pushing: need to expose our API to client

Conclusions:
The requirement of being able to define process-specific rule in a centralize place caused additonal coupling of services,i.e., requiring monitor and client services know each other. This is not scalable if we have many types of services we want to monitor.

-------------------

So how to design the framework, now that each service is responsible for the definition of state collector, i.e., which state to collect?

Previous discussion shows that the major problem is to pass client context to our monitor. Very hard to implement in a clean way with rich UI experience without close collaboration of monitor and clients.

Therefore, the design decisions are
Client is responsible for defining the internal states to watch for.
Client will push the state data to our monitor

Discussion:
1.What kind of settings can user specify for us, i.e., what kind of settings do we store on our monitor?
	
Anything not related to client’s domain context but related to our monitor,e.g., visual/formatting rules, authorization rules. But our monitor will not be responsible for converting the literal value to display value, and client has to compute them on their side and pass them to us

2. Authentication and authorization
Ideally, all services, including ours, should use SSO to simplify authentication. Authorization rule will be stored our side

3. Persistent layer design: what do we store
monitor viewer identities 
monitor editor identities
visual rules related to the monitor, e.g., formatting, type of monitored state: single value, list of values, histrogram?
actual state data, which includes:
literal value(s), display value(s), version info (e.g., timestamp)

4.User dynamics from UI level. Each side's UI should be single page app
On monitor side:
Visualization of monitored states
Define visualization rules
access control

On client side, do we need to expose UI for
access control?
visualization rules?
add/delete monitors?

----------
Tech stack
1. D3 is the most popular data visualiztion library, which is exactly what our monitor does
2. Persistant layer, should we use a schema less solution?
Which parts have rigid schema?
user id to viewable/editable monitors

Which parts do not have applicable schema?
data in our monitor sinks, because it may be a single value or a list of values. Moreover, the display value may be a number, string, or date
If we want to fit it into a schema-based solution:
one row for each solution: the cell has to contain multiple values: not that different from schema-less solution
one col for each solution: this means one table for each monitor sink. Each table has 2 columns: one for literal value, one for actual value, and we need a row counter just to enforce order in set logic

Also, because monitored data is so dynamic, the visual rules will be dynamic as well, i.e., may be a compisition of schema-based rules


3. Framework choice does not matter much in : 
web service layer, client side MVC, and client side interaction. Too many similar competitors
