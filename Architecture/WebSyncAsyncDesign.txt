Scenario:
On the web page, user wants to run long-running tasks asynchronously and be notified of changes

Discussion

Server-side => client side

Request/response model is synchronous in nature : request has to hold for response. Therefore, long running task can not do its work in the code that generates the response to user's kickoff request

=> We need to use half-sync/half-async pattern. So our web process will be the asynchrounous layer, and we will need a worker process as synchrounous layer. The two layers will communicate with a queue.
NOTE: in non-webapp settings, we may use worker threads instead of worker processes

So web process = our web server process

How to implement our synchrounous layer (worker process + queue)?
1. What to put into the queue?
Since this is inter-process communication, we cant just pass function pointers. We need to pass a portable form of function closure. The "portable form" depends on our queue implementation

2. So how to implement our queue?
We need use an existing queueing system. Redis is a common choice for light-weight solution. This means our function closure needs to be somewhat serialized, preferably human-readable.

Can we use relational database for such a queue? 

Conceptually, relational database, due to the nature of set logic, is not suitable for queue-related activities, which requires strong guarantee of ordering. 
Concretely, RDBMS's extensive use of corase-grained locking would greatly affect the enqueue/dequeue performance

3.How to implement the worker process?
The each thread in the worker process strongly resembles an interpreter: evaluating call of a function closure with arguments. Just as in an interpreter, the worker process doesnt have to be written in the same language/tools as the web process


Now how can client know of the status changes?
1. The async layer need to return client a handle. client can use the handle to get status
2. Two options to transer updates between client and server: 
    1.client polling
    2. server sets up a persistant connection/socket, and pushs the notification

In this case, since we are transferring only small amount of data, client polling is preferrable, because it has less overhead than socket approach. Note often polling uses exponential backoff.

 

