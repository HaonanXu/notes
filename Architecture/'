Context
A job has multiple steps. Each step corresponds to an action in a different application. We need to provide a portal so user can finish all steps in a single place,i.e., user should be able to do all 3rd party UI actions within our portal. Assume all 3rd party apps are web apps with URLs exposed.

Multiple users may have to do the same job => Our portal needs access control/authorization as well.

Discussion
1. How to display 3rd party's page within our portal?
put it in an iframe. Our portal and the 3rd party should use the same SSO for authentication and authorization

2.What do we need to store in our portal?
closure = function + environment
function: the URL to invoke 3rd party UI. 
environment: at minimum, the query parameters that can let 3rd party UI render correctly

3.How do we store the environment?
The relationship is that:
Define user's general environment
	Define a 3rd party app's general environment for that user
		Define a task's specific environment,i.e., parameter to the function

Our storage should follow this structure, within the inner environment being able to override outer environment. However, in practice this means we will focus on task environment first, and then we will add more general context as optimization 

4.How do we add a step to a job?
We need to get the list of apps => this list is centrally controlled by us, as we may need to maintain API keys for them anyway.
After that, we need to get list of viable URLs/actions in that app. The app needs to push the lists to us. The major problem with pulling is that we assume those apps have API for that(why we prefer push over poll, see discussion on the monitor's design)

Then how do we define parameters to that step?
3rd party pushs potential parameters and (maybe) potential values to us. Note that one major problem is validation of param values. We will have to rely on the 3rd party to do actual validation.

The benefit of 3rd party pushing is that it makes defining parameters behavior flexible,e.g., we can fill in the parameter and let the 3rd party refresh to show the effect, or go directly into 3rd party, modify its state, and let 3rd party push the updated parameter to us.

5.Our discussion in 4 implies that all users on the same step will be seeing same context in the 3rd party. What if we want to relax the constraint a bit, that is, two users on the same step of same job want to see something different?
This small relaxation can cause great implement problems
When defining a step, we need to get user specific parameter, this means we need to store user-specific parameter in the first place. But to get user-specific parameters
A.how many parameters from 3rd party context do we need? Gettting all would mean our system stores all user's context in all 3rd party apps. Scalability and consistency management would be nightmare
B. If a user-specific parameter is a collection, but the 3rd party URL needs only a single value, how dAccessible AriasAccessible Ariaso we determine which one to use?

Conclusions: we should not relax this contraint. All users on the same job's same step will see same thing. We can control facets of problems via new jobs and authorization control.

6.access control-visibility of steps. idea: sepearte step access from job access,i.e., a user's job may not have all steps visible to him.
The implication of this relaxation:
1.each step becomes standalone entitiy, and we need new utilities to manage them,i.e., assemble a job out of steps
2.what if I have 2 jobs, step in 1 is visialbe, and same step in 2 is not visible? => this means each step belongs to only one job
3.so each user needs to know which steps instead of jobs he can see => we can infer jobs from accessible steps.
Conclusions: this can be managed. We need to maintain group to steps relationship. Also need to maintain individual to steps relationship. Note that individual to steps relationship can not contradict group access rules

-----------------

Implementation consideration:
Is storage layer schemaless? relationships
group -> step
individual -> step
group -> individual
job -> step

step: service to use, URL to use, URL params as environment
The relationship part is
job -> step, 
user -> steps
group -> user








