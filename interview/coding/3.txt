Make 100 HTTP GET requests to http://en.wikipedia.org/wiki/Main_Page and print the following in Java 

statistics for the response time to stdout: 

• 10th, 50th, 90th, 95th, 99th Percentile 

• Mean 

• Standard Deviation 

Your solution must be parallel. You must make at least N (say 10, but should be configurable) 

requests at a time. 

Explain design choices, known limitations and edge cases. 

What challenges did you face? How would you improve the code if you had more time?

-------
Find all the abbreviations of string: 
eg 
ABC 
SOME Valid abbreviations are : 
1BC 
2C 
3 
A1C 
AB1 
A2 
NOT VALID 
11C(two numbers cannot occur continuously)

-------

Given a vector/list of doubly linked list pointers (a pointer is the directed linkage of two nodes), count how many independent blocks of linked lists there are for the pointers given.

-----

how to keep track of the sum in a sliding window for the data that are on disk 
rather than memory

------
Suppose you have a 2-D grid. Each point is either land or water. 
There is also a start point and a goal.
There are also keys that open up doors. Each key corresponds to one door. 
Implement a function that returns the shortest path from the start to the 
goal using land tiles, keys and open doors.

Data Representation
The board will be passed as an array of chars.

A board can have the following tiles.
0 = Water 
1 = Land
2 = Start
3 = Goal

uppercase = door
lowercase = key
Example Maps (keys at each step are not required)
`No doors`
char[][] board1 = {{'0', '2', '1', '1', '1'},
				   {'0', '1', '0', '0', '1'},
				   {'0', '1', '0', '0', '3'},
				   {'0', '1', '0', '0', '1'},
				   {'0', '1', '1', '1', '1'}};
path : [0,1]->[0,2]->[0,3]->[0,4]->[1,4]->[2,4]

`One door`
char[][] board2 = {{'0', '2', '1', '1', '1'},
				   {'0', '1', 'a', '0', 'A'},
				   {'0', '1', '0', '0', '3'},
				   {'0', '1', '0', '0', '1'},
				   {'0', '1', '1', '1', '1'}};
path : [0,1]->[0,2]->[1,2]->[0,2]->[0,3]->[0,4]->[1,4]->[2,4]
public List<int[]> solve(char[][] board) {

------

Given a large file with sentences and query string, design a system (Class, data structs, functions, etc) and algorithm to return the smallest window (start and end offsets) in the input file where the query words (in any order) are seen in the text file. What is the time complexity?

------

Given a binary tree, return all the longest path between any two nodes in a tree. This path may or may not pass through the root. 
Example: 
Given a binary tree


/**
 * Definition for a binary tree node.
 * public class TreeNode {
 *     int val;
 *     TreeNode left;
 *     TreeNode right;
 *     TreeNode(int x) { val = x; }
 * }
 */
          1
         / \
        2   3
       / \     
      4   5  
Return [4,2,1,3] and [5,2,1,3].

Public List<List<Integer>> getLongestPath(TreeNode root) {
        
    }

-------

Generate a random 4-digit even number : the adjacent 2 digits must be different. 
public int getNumber(){ 
}

------

write a function that randomly return a random Fibonacci number in range [min, max) 
public int getRandom (int min, int max){}

------

Given a large MxN matrix of 1s and 0s like this:


1 1 0 0 1 0 1
1 0 1 0 0 1 1
0 1 1 1 0 1 0
...
Calculate the number of 1s in a given subset PxQ matrix. In effect, write a function:


int ones(int startx, int starty, int len, int width);
Looking for something better than O(n^2).

--------

Given a count and maxvalue, write a program to return count number of unique random integers between 0 and maxvalue.

--------
tokenize string, "" and [] are token flags, such as 
mytable "foo" [bar] "" [[[[]]]. 

"" Turned into ",]] turned into], [[not escaped 
The results of the example given above: 
mytable 
foo 
bar " 
[[] 
public List<String> tokenizestring(String s){ 
}

--------

Find the Lexicographic next word of the input word from a list of words 
Example 
Words list 
[Cat, dog, cow, donkey, zebra, monkey], 
input 
duck 
output 
monkey 

Input 
dog 
output 
donkey 
Can you use trie to solve it? 
public String findNextWord(List<String> words, String input){ 
}

-------

Given a equation in the form of "3x+4y+2=-5y+2x+10", simplify the equation to be in form "y=Ax+B", and return A,B. Also allow parenthesis to be in the equation. Ex. "3y-4x+(3-(2x-3y))=10y", result is "y =0.75 - 1.5x"

------

Given a list of files. Return all the unique lines from all files.

------

Question Given two strings s1 and s2, combine the characters in the strings and maintain the sequence of characters 
Follow-up If s1 has a length of m and s2 has a length of n, how many ways the strings could be merged. Figure out the formula F(m, n) = ?

------

For a string chemical formula like “C6H2(NO2)3CH3”, and output a map with key as element and value as its count. 
element can have two chars, for example Fe2(SO4)3 
public HashMap<Character, Integer> getCount(String chemicals){ 
}
------

/**
 * Definition for a binary tree node.
 * public class TreeNode {
 *     int val;
 *     TreeNode left;
 *     TreeNode right;
 *     TreeNode(int x) { val = x; }
 * }
 */
Find if a given binary tree has duplicate sub trees. 
followup: 
Find all duplicate subtrees in a binary tree


For example,

        1
       / \
      2   3
     /   / \
    4   2   4
       /
      4
The following are two duplicate subtrees:

      2
     /
    4
and

    4
Therefore, return [ [2,4], [4] ].
------

Create an iterator class that stores a list of the built-in Iterators. 
Implement the next() and hasNext() methods in a Round Robin pattern (pops next element in a circle). 
Example: 
Given a list [iterator1,iterator2, iterator3...] 
when calling RoundIterator.next() 
pops iterator1.next if iterator1.hasNext() is true 
when calling RoundIterator.next() 
pops iterator2.next() if iterator2.hasNext() is true 
when calling RoundIterator.next() 
pops iterator3.next if iterator3.hasNext() is true 
... 
when calling RoundIterator.next() 
pops iterator1.next if iterator1.hasNext() is true 
when calling RoundIterator.next() 
pops iterator2.next if iterator2.hasNext() is true 
when calling RoundIterator.next() 
pops iterator3.next if iterator3.hasNext() is true 
... 
until there is no more element in any of the iterators

------



