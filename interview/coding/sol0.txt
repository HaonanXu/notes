1.
n - num9(n) = t, then we are good, here t = 8

notice this fx is non-decreasing

9 - 1 = 8

8 - 0 = 8

int newNumber(int n)
	return newNumber(n, int.max, n); 

int num9 (int n) {
	if(n < 10){
return n >= 0? 1 : 0
}else{

int complete10s = num3(n / 10 - 1);

if(hasDigit3(n))
	return complete10s
else
	return complete10s + num3(n % 10);
}
}



int newNumber(int l, int h, int t){
	if(l == h)
	{
		if(has9(l)){
return l -1;
else
return l;
	}

int mid = (l + h) /2

int fx = n - num9(l)

if(fx > t)
	return newNumber(l, mid, t);
else if(n - num9 < t)
	return newNumber(mid + 1, h, t) 
else
	return newNumber(mid, mid, t);
} 

----------
2.
Think about Kruskal's algorithm, when we are trying to add new edge, we need to detect if it is already within the same component. To do so, we use a union-find to maintain the component we have so far. But now consider the directed graph, the direction matters and there is no obvious way to tell the orientation of the edge

--------
3.
Use randomzied top k algorithm


