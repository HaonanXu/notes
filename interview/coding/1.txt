Given a n*m size 2D array with integers from 1 to n * m -1, sort it with a movable block , by swapping with any neighbor, and eventually you want to movable block back. Think of an approach to print the path

---------

Given a very large file of 10 GB containing product price, Sort the file of product if memory available is 1 GB 

read the file into 10 chunks, sort them each file, and then maintain 10 pointers and do a merge, and write to a new file 


------
There are N gas stations along a circular route, where the amount of gas at station i is gas[i]. 
You have a car with an unlimited gas tank and it costs cost[i] of gas to travel from station i to its next station (i+1). You can begin the journey with an empty tank at one of the gas stations. 
Return ALL the starting gas station's index where you can travel around the circuit once 
public List<Integer> canCompleteCircuit(int[] gas, int[] cost) { 
}


---------
Given a task sequence tasks such as ABBABBC, and an integer k, which is the cool down time between two same tasks. Assume the execution for each individual task is 1 unit. 
rearrange the task sequence such that the execution time is minimal. 
Example: 
S = AAABBBCCC, K = 3 
Result: ABCABCABC (all 'A's are 3 distance apart, similarly with B's and C's), thus return 9 
S = AAABC, K=2 
Result: ABCA_ _A, thus return 7 
S = AAADBBCC, K = 2: 
Result: ABCABCDA, thus return 8 
public int rearrangeTasks(String tasks, int cooldown){ 
}

---------
Given an array of n elements which contains elements from 0 to n-1, with any of these numbers appearing any number of times. Find these repeating numbers in O(n) and using only constant memory space. 
Try to do it in one pass 
example 
[4, 2, 0, 5, 2, 0, 1] return: 0, 2 
[1, 2, 3, 0, 0, 1, 3, 6, 6,6] return 0, 1, 3, 6 
public List<Integer> findRepeat(int nums[]){ 
}

---------

Given a Binary tree (Not binary Search Tree ), find the inorder successor of a node.

inorder: left, mid, right

if current node has right child, then it will be left most leave of the right child
otherwise, it will be the first right child of its parent



class TreeNode{
    TreeNode left;
    TreeNode right;
     int val;
    public TreeNode(int val){
        this.val = val;
    }
}

public TreeNode inOrderSuccessor(TreeNode root, TreeNode n) {
}


-------

Given a positive integer n, find the no of integers less than equal to n, whose binary representation doesn't contain consecutive 1s. 
eg: 
I/P : 4 
O/P: 4 (0,1,2,4 Valid) 

(!!!)


-------
A "derangement" of a sequence is a permutation where no element appears in its original position. For example ECABD is a derangement of ABCDE, given a string, may contain duplicate char, please out put all the derangement 
public List<char[]> getDerangement(char[]){}

similarly: print all anagrams of a string

-------

there is a bunch of tasks, each have different time to complete, task is independent, and then there are some workers, 
How to allocate tasks to these workers to minimize the total time to complete all the task. The tasks can be randomly picked from the task list. 
Example 
Task: 2,2,3,7, 1 
Worker: 2. 
Return 8, because the first worker can work on the first three tasks : 2 + 2 + 3 = 7, and the second worker can work on the last two tasks : 7 + 1 = 8, so the total time to finish all the task is 8. 
public int getMini(int[] tasks, int k)

------

Give you an unsorted integer iterator 
and a percentage that is expressed in double (for example, 0.4 for 40%), 
and find the number of the sorted array at the percentage position. 
Example: Enter [1 3 2 5 4 6 7 9 8 10], and 0.6, you will return 6 
public int findNumber(Iterator<Integer> nums, double percent){ 
}

-------

There are 3 romms in which party is going on lets say room A, B, C. Guests are coming one by one and you have to tell the guest 
which room to enter. At any point of time each room has to maintain a percentage Lets say the percentage that each room has to maintain is 
A- 20% , B-30% , C- 50%. You can maintain total count of each room and keep on adding count to respective room as the new guest enters each room. 
How would you go about it. What formula would you use. 
Give a generalise formula so that it works if no. of rooms increase.

------
You are given a 2d rectangular array of positive integers representing the height map of a continent. The "Pacific ocean" touches the left and top edges of the array and the "Atlantic ocean" touches the right and bottom edges. 
- Find the "continental divide". That is, the list of grid points where water can flow either to the Pacific or the Atlantic. 
Water can only flow from a cell to another one with height equal or lower. 

Example: 

Pacific ~ ~ ~ ~ ~ |__ 
~ 1 2 2 3 (5) ~ 
~ 3 2 3 (4)(4) ~ 
~ 2 4 (5) 3 1 ~ 
~ (6)(7) 1 4 5 ~ 
__ (5) 1 1 2 4 ~ 
|~ ~ ~ ~ ~ Atlantic 

The answer would be the list containing the coordinates of all circled cells: 
[(4,0), (3,1), (4,1), (2,2), (0,3), (1,3), (0,4)]

--------

Given an m x n matrix where each row element is sorted, but the columns do not appear in sorted order, write a function to print each matrix element in sorted order. 

Example matrix: 
matrix = [ 
[20, 40, 80], 
[5, 60, 90], 
[45, 50, 55] 
] 

Your function should print 5, 20, 40, 45, 50, 55, 60, 80, 90. 

Add on: Assume that we are space-constrained such that we can only hold one row in memory at a time. Optimize your function to work under such constraints as efficiently as possible.

---------

Write a program that reverses a linked list without using more than O(1) storage.

-------

Write a program that answers YES/NO search queries containing * placeholders. Example: if the data you have is (hazem, ahmed, moustafa, fizo), then you should answer as follows for: 
 ahmed: YES 
 m**stafa: YES 
 fizoo: NO 
 fizd: NO 
 *****: YES 
 ****: YES  
**: NO 
 Your program should be able to answer each search query in O(1).

-----

Input: A string equation that contains numbers, '+' and '*' 
Output: Result as int. 

For example: 
Input: 3*5+8 (as String) 
Output: 23 (as int)

-------

Given a class Range


class Range {
	public int begin;
	public int end;
	public Range(int begin, int end) {
		this.begin = begin;
		this.end = end;
	}
}
The problem: 
Intput: 
1) list of Ranges that don't overlap (not sorted) 
2) newRange that might overlap. 
Output: 
list of merged Ranges 

For example: 
Input: [1..5] [9..13] [17..22] 
newRange: [4..10] 
Output: [1..13] [17..22]

--------

Convert a binary tree into a In Order traversal circular list re-purposing the node's pointers Left & Right as Previous and Next respectively. 

Hint: A single node Left & Right points to itself. 

Note: This is not a binary search tree.

--------

First they did ask to find pattern of this


'this is a test sentence' => [t, h, i, s, i, s, a, t, e, s, t, s, e, n, t, e, n, c, e]
'thiis iss a teest seentennce' => [i, s, e, e, n]
'thiiis iss aa teeest seentennnce' => [i, e, n]
'thiiiis iss a teeest seeentennncccce' => [i, c]
after i have to do body of function


getLongestConsecutiveChar

------

You are given a set of unique characters and a string. 

Find the smallest substring of the string containing all the characters in the set. 

ex: 
Set : [a, b, c] 
String : "abbcbcba" 

Result: "cba"

------

Inplace reverse a sentence 

You given a sentence of english words and spaces between them. 
Nothing crazy: 
1) no double spaces 
2) no empty words 
3) no spaces at the ends of a sentence


void inplace_reverse(char* arr, int length) {
    // your solution
}
Example: 
input "I wish you a merry Christmas" 
output "Christmas merry a you wish I" 

Constrains: O(1) additional memory

--------

Given an array of integers, return true if there're 3 numbers adding up to zero (repetitions are allowed) 
{10, -2, -1, 3} -> true 
{10, -2, 1} -> true -2 + 1 +1 =0

-------
Write a function to print the rows of a binary tree, terminating each row with a carriage return

----
There is a list of rectangles and a list of points in a 2d space. Note that the edge of each rectangle are aligned to XY axis. question is how to find rectangles with point or points inside

--------
Array of size (n-m) with numbers from 1..n with m of them missing. Find one all of the missing numbers in O(log). Array is sorted. 

Example: 
n = 8 
arr = [1,2,4,5,6,8] 
m=2 
Result has to be a set {3, 7}.

--------

You are given an array of non-negative integers (0, 1, 2 etc). The value in each element represents the number of hops you may take to the next destination. Write a function that determines when you start from the first element whether you will be able to reach the last element of the array. 

if a value is 3, you can take either 0, 1, 2 or 3 hops. 

For eg: for the array with elements 1, 2, 0, 1, 0, 1, any route you take from the first element, you will not be able to reach the last element.

-------

There's a new language which uses the latin alphabet. However, you don't know the order among letters. 

It could be: 
a b c d ... 

as it could also be: 

b e z a m i ... 

You receive a list of words lexicographically sorted by the rules of this new language. From this list, derive one valid particular ordering of letters in this language.

-----
Write a program to find pattern. 

0: 1 
1: 11 
2: 21 
3: 1211 
4: 111221 
5: 312211 

Iterate over the previous number, and find count for same number number. Append that count before number. 

e.g., 

public String pattern(int input){} 

If input = 4, function should return 111221.

-------

Suppose we have array of N numbers. We will define N functions on this array. Each function will return the sum of all numbers in the array from Li to Ri ( Li is left index, Ri is right index). Now we have 2 types of queries: 

Type1: 1 x y Change the xth element of the array to y 
Type2: 2 l r Return the sum of all functions from m to n. 

Input type: 
First Line is the size of the array i.e. N 

Next Line contains N space separated numbers Ai denoting the array 

Next N line follows denoting Li and Ri for each functions. 

Next Line contains an integer Q , number of queries to follow. 

Next Q line follows , each line containing a query of Type 1 or Type 2 

Here is an example: 
Input: 
5 
1 2 3 4 5 
1 2 
3 4 
1 4 
1 5 
3 5 
5 
1 1 5 
2 2 4 
2 1 3 
1 4 5 
2 1 5 

Output: 
40 
28 
63 

Explanation: 
Function 1 is sum of values from index 1 to index 2 = 1+2=3 
So , F1=3 
Similarly, F2=3+4=7 
F3=1+2+3+4=10 
F4=15 
F5=12 

Now when I query 1 1 5 
means it is type 1 query, so we replace value at index 1 by 5. 
So our new array is, 
5 2 3 4 5 
and 
F1=7 
F2=7(unchanged) 
F3=14 
F4=19 
F5=12(unchanged) 

Then next query is 2 2 4 
means give sum of all functions from index 2 to 4. 
So, ans= 7+14+19 =40 (output 1) 

Similarly are other 2 outputs. 
Index are 1 based in example. 
Comment me if you are not clear with question. 

Edit: I know one can do it with naive approach or using segment tree. But they wanted more faster way to do it.

-------

Having a home-defined linked list with the following structure, where the next will point to the next node in the list and the random will point to a random node in the list (not null). 
Create a copy of the structure (the data field in each node is not unique for different nodes): 

/* 
Example: 
Having the list: 
1 -> 2 -> 3 -> X 
With random pointers to: 
1: 3 
2: 2 
3: 1 

Create the list: 
1' -> 2' -> 3' -> X 
1': 3' 
2': 2' 
3': 1' 
*/ 

class Node { 
int data; 
Node next; 
Node random; 
}

--------
You're given an array of integers(eg [3,4,7,1,2,9,8]) Find the index of values that satisfy A+B = C + D, where A,B,C & D are integers values in the array. 

Eg: Given [3,4,7,1,2,9,8] array 
The following 
3+7 = 1+ 9 satisfies A+B=C+D 
so print (0,2,3,5)


------

Given a dictionary of words, return an array of the words whose match. (i.e. pattern "c.t" match with "cat", "cut", etc. because the dot notation stand for ANY character). 


SUGGEST: use suffix tree, for(for()) is not a good solution.

-----
Given an array of positive integers that represents possible points a team could score in an individual play. Now there are two teams play against each other. Their final scores are S and S'. How would you compute the maximum number of times the team that leads could have changed? 
For example, if S=10 and S'=6. The lead could have changed 4 times: 
Team 1 scores 2, then Team 2 scores 3 (lead change); 
Team 1 scores 2 (lead change), Team 2 score 0 (no lead change); 
Team 1 scores 0, Team 2 scores 3 (lead change); 
Team 1 scores 3, Team 2 scores 0 (lead change); 
Team 1 scores 3, Team 2 scores 0 (no lead change).

--------

Given a mapping of alphabets to integers as follows: 

1 = A 
2 = B 
3 = C 
... 
26 = Z 

Given any combination of the mapping numbers as string, return the number of ways in which the input string can be split into sub-strings and represented as character strings. For e.g. given 
"111" -> "AAA", "AK", "KA" -> 3 
Valid combinations are ({1,1,1}, {1,11},{11,1}) = 3 
"11" -> "AA", "K" -> 2 
Valid combinations are ({1,1},{11}) = 2 
"123" -> "ABC", "LC", "AW" -> 3 
Valid combinations are ({1,2,3},{1,23},{12,3}) = 3 

You don't have to return all the mappings, only the number of valid mappings.

--------

Let's say you have 10,000 servers, each with a billion integers. How do you find the median?





