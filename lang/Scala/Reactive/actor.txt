blocking sync introduces dea-locks
blocking is bad for CPU utilization
sync ommunication couples sender and receiver
----
actor : object with id
has a behavior
only interacts using synch message passing

class Counter extends Actor {
var count = 0
def receive = {
 case "incr" => count += 1
 case ("get") => sender ! count
}

}

def counter(n: Int): Receive = {
 case  "incr" => context.become(countter(n +1))
 case "get" => sender ! n
}

def receive = counter(0)

class Main extends Actor {
 val counter - context.actorOf(Props[Counter], "counter")

counter ! "incr" //inside itself, self will be sender
counter ! "get"

def recive = {
	case count: Int =>
	context.stop(self)

}

}
-------
every actor knows its own address
creating an actor returns its address
addresses can be sent within messages

messages are received sequentially
behavior chagne is effective before proccesing the next message
processing one message is the atomic unit of execution(!!!)
=> actor is effectively single-threaded with blocing replaced by enqueueing a message

JVM flags to do akka logging
-Dakka.loglevel=DEBUG -Dakka.actor.debug.receive=on


3 messages delivery guarantees: 
at-most-once: just send, no state
at-least-once: rsend until ack is recieved, sender needs to buffer
and exactly-once: only the first received in processed, sender needs to buffer, receiver needs to know which have been done

good thing for messages: all messages can be persisted
can include unique correlation IDs => enables exactly once
delivery can be tretried until successufl

make transfer relaible

log activitis of wiretransfer to persistent storage
each transfer has a unique ID
add ID to withdraw and deposit
store IDs of completed actions within bankaccount

In akka, if an actor sends multiple messgae to the same destination, they will not arrive out of order

-------
Akka scheduler: high vol, short durations, and frequent cancellation

reactive applicaito is non-blocking and event-drivent top to bottom
actors are run by a (shared) dispatcher, which can also run futures
prefer imutable data structures
prefer context.become for differnet stats, with data local to the behavor
do not refer to actor state from code running synchronously
