trait Functor[F[_]] {
  def map[A,B](fa: F[A])(f: A => B): F[B]

  def distribute[A,B](fab: F[(A, B)]): (F[A], F[B]) =
    (map(fab)(_._1), map(fab)(_._2))

  def codistribute[A,B](e: Either[F[A], F[B]]): F[Either[A, B]] =
  e match {
    case Left(fa) => map(fa)(Left(_))
    case Right(fb) => map(fb)(Right(_))
  }
}

val listFunctor = new Functor[List] {
  def map[A,B](as: List[A])(f: A => B): List[B] = as map f
}

a type constructor like List (or Option, or F) is a functor, and the Functor[F] instance constitutes proof that F is in fact a functor.

def sequence[A](lma: List[F[A]]): F[List[A]]
def traverse[A,B](la: List[A])(f: A => F[B]): F[List[B]]

def replicateM[A](n: Int, ma: F[A]): F[List[A]]

flatMap obeys an associative law: 

x.flatMap(f).flatMap(g) == x.flatMap(a => f(a).flatMap(g))

def compose[A,B,C](f: A => F[B], g: B => F[C]): A => F[C]

Kleisli arrows
compose(compose(f, g), h) == compose(f, compose(g, h))

A monad is an implementation of one of the minimal sets of monadic combinators, satisfying the laws of associativity and identity.

We could say that monads provide a context for introducing and binding variables, and performing variable substitution.

case class State[S, A](run: S => (A, S)) {
  def map[B](f: A => B): State[S, B] =
    State(s => {
      val (a, s1) = run(s)
      (f(a), s1)
    })
  def flatMap[B](f: A => State[S, B]): State[S, B] =
    State(s => {

      val (a, s1) = run(s)
      f(a).run(s1)
    })
}

 type lambda and StateMonad

The Monad contract doesnâ€™t specify what is happening between the lines, only that whatever is happening satisfies the laws of associativity
and identity.
