spray-routing makes all relevant parts of the routing DSL available through the HttpService trait

 In order to have access to all HttpService members in your service actor you can either mix in the HttpService trait and def actorRefFactory = context

or, alternatively, derive your service actor from HttpServiceActor class, which already defines the connecting def actorRefFactory = context for you

when a route receives a request (or rather a RequestContext for it) it can do one of three things:
Complete the request by calling requestContext.complete(...)
Reject the request by calling requestContext.reject(...)
Ignore the request (i.e. neither complete nor reject it)

There are three basic operations we need for building more complex routes from simpler ones:

Route transformation, which delegates processing to another, “inner” route but in the process changes some properties of either the incoming request, the outgoing response or both
Route filtering, which only lets requests satisfying a given filter condition pass and rejects all others
Route chaining, which tries a second route if a given first one was rejected
The last point is achieved with the simple operator ~

A directive does one or more of the following:
Transform the incoming RequestContext before passing it on to its inner Route
Filter the RequestContext according to some logic, i.e. only pass on certain requests and reject all others
Extract values from the RequestContext and make them available to its inner Route as “extractions”
Complete the request

& and | for composing directives



