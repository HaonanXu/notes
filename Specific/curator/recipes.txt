-----
Leader Latch

create LeaderLatch
leaderLatch.start()
hasLeaderShip()
await()

Once through LeaderLatch instance, close(). removes the instance from the leader electio and releases leadership if the isntance has it


Error handling:

1. if connection that is leader suspended or lost, there will be no leader until connection is re-established, and LeaderLatch reports that
it is no longer the leader. 

2. Upon leader re-connection, it will delete previous ZNOde and create a new node

3. make sure register a ConnectionStateListener to handle that connection issues can cause leadership to be lost

---
leader election

once started, takeLeadershp() of your listener will be called when you have leadership. Your teakLeadership() should retun only when
leadership is being relinquished

Error handlding:
Upon suspended or lost, throw CancelLeadershpException => extend LeaderSelectorListenerAdapter

------
Shared reentrant lock

acquire() is blocking, EACH call to acquire must be balanced by a call to release()

Re-use a single instance instead of creating new one

supports coop revoking => another process can force release the lock

Error handling:
if a SUSPENDED state is reported, you can not be sure if you still holde the lock unless you receive a reconected state

if a lost state is reported it is crertain that you no longer hold the lock

------
