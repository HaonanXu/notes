--------
Transaction on KV

Layers:
Transaction -> MVCC -> Raft KV -> Rocks DB

//return max version of the value <= version
MVCCGet(key, version)
MVCCScan(startKey, endKey, limit, version)

//write k-v at version, user is responsible for ensure auto-increment of user
MVCCPut(key, value, version)

Inside RocksDB, it stores

key -> all key version info
key + version1 -> value at v1
key + version2 -> value at v2

Note we will split key with version value to avoid too huge updates
--------
1. buffer all update/delete on client side

2. Prewrite primaryRow: 
	a. lock the primaryRow with the start time of current transaction, if there is no other client locking the same primaryRow, and if there is any Write happened during (startTs +inf)
	b. if we can not lock primaryRow, that means there is potental conflict - rollback a
	c. add key+startTs -> new value

3. Prewrite secondaryRow, follows similar steps of primaryRow, except that the content of the lock is the one for primaryRow

4. commit primary: add a new vesion to meta, at commitTs, version startTs

5. delete the lock in meta


4. commit primary, write to W column new data: startTs at commitTs

5. commit secondaries asychly



During read in transaction:
1. check if the row has L column in [0, startTs] => wait for its timeout or release
2. read W column, in [0, startTs], convert to proper timestamp, and read the column at version timestamp

-------

PD provide a timestamp oracle for increasing (not necessarily continous) timestampes, provided by PD

physical time + logical time
1. when PD becomes leader, will get last saved time from etcd, and hold until current time >= that value
2. apply a lease to etcd, within this window PD will be the TSO
3. client batchs n request and get TSs togehter from PD

------
To split region
1. Leader peer sends request to PD
2. PD creates new region ID and peer ID, and return to leader peer
3. leader peer writes the split action into a raft log, and execute it at apply
4. Tikv tells PD, PD updates cache and persist it to etcd
