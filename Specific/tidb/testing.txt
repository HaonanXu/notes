Over 6 million automated tests, use program to generate SQL and run, see if it crashes

do A/B test, run it again other DBs, and see if results are consistent

performance issues evaluated by user

profile everything, even on production

tests may make your code less beautiful. May need to add members to structs just for testsings

use record-replay to caputure all sql statements, and then replay it

check rate of errors 3% for CPU on disk 

Importatnt to monitor NTP

reading data from disk without checksum => no protection against potential data corruption

Fault injection: disk error, netowrk card, cpu, clock, file system, network & protocol => need to simulate everything so that you can inject error

libfiu

openstack FI factory

Jepsenï¼š heavy weight, from a control node, ssh into db nodes, many control process, a nemesis process will try damage the DS,e.g., iptable to disconnect network connection, in the end use a checker to verfiy results
=> check PingCAP's use of Jepsen

FoundationDB: fake multi-process, however, for some languages like go, even single thread is in effect multi-threaded,e.g., channel
=> secondary approach, no need to be deterministic, as long as it is reasonable

cloudera fault injection: 

iptable block as protection from many concurrent connections

dont test failure case by triggering failure automatically, use your simulation layer

Treat storage as a black box.
Three steps(7*24):
Fill data, Random kill -9
Restart
Consistent check.

Namazu

American fuzzy lop
