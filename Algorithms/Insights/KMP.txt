m: current match start at index m of S
i: current match at index i of W, i.e. S[m + i] = W[i]

---
Second stage ops

if matchs => increment i

if mismatch, we want to move m as close to i as possible, that is, we want to
find highest m such that m...i-1 is a prefix of W, so we need to answer

at i of W, what is longest prefix of W that is also the suffix of W[0... i-1]? no that we dont even
care about S now! 

so m = m + i - T[i], i = T[i]

----
Runtime of the second stage
1. by defintion of our problem, T[i] <= i
T[i] < i, because we know m has to increase after a mismatch

if match => m+i increase by 1
if mismatch => m+i stays same, m is increased by at least 1, so in total, each
branch can execute at most length(S) times => 2n times loop max


---
Build the T[i] table

insight: we can infer T[i]'s state based on T[i-1]'s state:
if W[i - 1] = W[T[i - 1]], then T[i] = T[i-1] + 1 //infer T[i] based on T[i-1]

T[0] = -1 //invalid
T[1] = 0 //special case

else if T[i - 1] <= 0, T[i] = 0 //last one doesnt match, 


