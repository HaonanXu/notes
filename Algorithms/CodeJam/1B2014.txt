notice we only rubber band strings. i.e. all can be reduced into form abcd...where a, b, c,d are distince letters
so first, they need to reduce to the same basic form
what is their final form?
for each position, try N from 1 to 100, and compute count
total cost 100 * 100 * 100

-------
A,B, K= 10^9, so closed form, logN runtime expected, check patterns
0: no position has both 1, i.e.,
1: right end has both 1, no position has both 1 to left
2: 0...010

because of the value constraint, bits are not independent generation..
#(final value < K) = #(final value < K and final value >= 2^leading 1 pos) + #(final value < 2^leading 1pos)
so second part is recursion..how about first part?
first part = #(leading digit is 1) - #(generated number >= k, when A, B, bigger than first 2^n

consider first digit of K at position s, v = 2^s, WLOG, assume, A,B start at the same digit
D(A,B,K) = 
(v) * (B-v) //0, 1
(A-v) *(v) //1, 0
(v) * (v) //0,0
(A-v)(B-v) - U(A-v, B-v, K-v) //1,1
U(A,B,K) = WLOG, assume A,B with same digit
(A-v)(B-v) - D(A-v, B-v, K-v) //first digit at least one


pseudo code, WLOG, assume A >= B >= K

D(A, B, K)
{
//need to swap a,b here
//base case B = 0 total = A

get first bit of A = v

if(K < v) //first bit is 0
	if (B < v)
		return A-v * B - U(A-v, B, K) + v * B - U(A-v, B, K) //1,0 and 0, 0
	else
		return A-v * v - U(A-v, v, K) + v * v - U(v, v, K) //1,0 and 0, 0
else
	if (B < v)
		return 0; //invalid case
	else
		return A-v * B-v - U(A-v, B-v, K-v)
}


WLOG A>=B>=K
U(a,b,k)
{
//need to swap a,b here
//base case B<= K, total = 0

get first bit of a =v

if(k < v)
	if (b < v)
		return U(a-v, b, k);
	else
		return a-v * b-v //1,1
		+ U(a-v, b-v, k) //0, 0
		+ a-v * v - D(a-v, v, k) //1, 0
		+ v * b-v - D(v, b-v, k) //0, 1
else
	if(b < v)
		return 0; invalid case
	else 
		return a-v * b-v - D(a-v, b-v, k-v) //1,1 

}
-----------

starting city must be of lowest number (greedy)
so for each next stop, we need to get the next lowest number! insite similar
to Kruskal MST/Dijkstra!

heap<postal, id> h
sort postals ps

visited = {ps[0].id}

foreach n in neighbor(ps[0])
	h.add(postal[n], n)

finalString = ps[0]

while(visited.size <= full)
{
	next = h.pop

	finalString += postal[next]

	foreach n in adj[next]
	{
		if(visited has n)
			continue;
		
		h.add(postal[n], n)
	}
}


