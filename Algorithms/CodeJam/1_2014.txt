notice that flipping bits are independent. Also, if we have a solution, no
more than half of the bits are flipped, i.e., at most 20 flipped in the
solution
for each bit column, if #0s and #1s are different, we know for sure to flip or not
if they are same....

or think horizontally
find the mapping for source i to target j => 150^2 choices
for each choice, we can infer a flipping order, verify this flipping
order,i.e.,

for each mapping
	get fillping order
	for each row
		apply map to row
		if mapped is occupied, error
		else marked as mapped

total cost will be 150*150*40
--------
notice we only rubber band strings. i.e. all can be reduced into form abcd...where a, b, c,d are distince letters
so first, they need to reduce to the same basic form
what is their final form?
for each position, try N from 1 to 100, and compute count
total cost 100 * 100 * 100
--------

WLOG, assume, P/Q are of lowest fraction

P/Q = (A* D + B*C) / (D *B * 2)

Insight 1: q must be of form 2^gen

1st gen: 1, 0, 1/2
2nd gen, 1, 0, 1/2, 3/4, 1/4
3rd gen, 0, 1/8, 1/4, 3/8....

Cliam: all possible numbers cover all digits

if there is no 1 in the family at all => P must be 0, i.e, at least 1'1 in first gen, 

1st gen,
1,1/2
second gen
1 1/4, 3/4,

so odd case, partition into 1 + even => and even is from 1

to get min number, lowest 1 => max share

given P/Q
sanitize: P != 0, P <= Q, Q must of form 2^n

Gen(P,Q)
{
	if(P == 1)
		get answer based on value of Q
	if(P%2 == 0)
		return Gen(P/2, Q/2)
	else
		return 1 + Gen(P-1, Q/2)
}
