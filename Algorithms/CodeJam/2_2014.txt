----
A:
Insight: calculate min deletion is equivalent of calculating max retention => computation becomes much easier. So my count part is not needed

linear solution: pre-compute 3 largest subtree

each pre-computation part has
node, parent, largest 3 childs along with its size, pick a random root node and start DFSing

how do we fix the root node? we will try to move the root to a child position, and see if it can improve overall size count,e.g., if root become first level child, second level child....etc. This means we need to try to make each node root once, note if we do DFS/BFS, we can reuse previous step's calculation result=> instant calc. Another insight is that, when we are making a root, the state in the root would be enough the determine the total maxsize, even though we do not know the arrangement of the rotated out root
---------
B:
DP on bits, since value itself is too big, consider container/uninterpretated value instead of value itself
motivating question: calculate # of number of < than M, recursively

this also means, at least level, we need to know if we are less than previous
prefix or not,i.e., are we in free mode?

another approach is to base on least significant bit, divide search space into
different sets. Consider pairs (a,b) that is the solution space

if(a, b) both even, (a, b) both odd, a odd, b even, a even, b odd
--------
C:
consider the case ab
if b has multple choices, i.e., many b*, then these b* should connect, , or invalide, i.e, at most 1 form of 
i.e, at most 1 form of b*, remaining bb

so with ab, the b* as tail is fixed!
same as *a

so preprocess
if there is one with form abc, the answer is 0
2 sets, of form aa, of form ab
in 2nd set
each letter can appear in head at most once, in tail at most one
otherwise error


cur head = first
cur tail = first

foreach (in ab set)
	if can head
		head
	if can tail
		tail

for each break, including head/tail
	overall * # of aa!

try to connect to last head/tail with same

distince at head or tail

