Common problem solving heuristics with LIS: 

1. Reduction:
best solution <=> longest list
core insgiht:
each step, all potential candidates must appear before the step, and NO candidate can appear after the step, and we will pick one of them 

May need O(nlogn) (However, be aware of the risk of being distracted by detail too early!)

2. from unknown to data:
what properties would the solution have? does it satisfy the core LIS insight


--------
2. LIS: a discontinuous sorted linked list, so cant bsearch directly on it

3. Consider a mapping f: rank of element -> index of element, LIS means that
"lines" of mapping will not intersect with each other, i.e., the mapping
retains the relative order between the elements. More genericly, in the final solution, f(a, b) is always determined by relative position of a, b. This also means all potential answers for b, if they can appear in the solution, must appear before b

4. Aside from nlogn DP solution, we can use a topo sort to build the linked
list tree, because we know a < b < a can not happen,i.e., the graph must be
acyclic

But DFS in the topo sort may require too much stack space => have to use DP solution

After topo sort is done, we can relax in the topo sorted order

in topo order n....1
	for each neighbor in node order[n]
		longsetLink[neighbor] = longestLink[n] + 1

This topo sort and relax pattern alos applies to the shorest path of acyclic graph

5. Two recurrence relationship options. Need to see which one fits in LIS variants
